{
 "id": "764468",
 "text": "In computability theory Post's theorem, named after Emil Post, describes the connection between the arithmetical hierarchy and the Turing degrees. == Background == The statement of Post's theorem uses several concepts relating to definability and recursion theory. This section gives a brief overview of these concepts, which are covered in depth in their respective articles. The arithmetical hierarchy classifies certain sets of natural numbers that are definable in the language of Peano arithmetic. A formula is said to be \\Sigma^{0}_m if it is an existential statement in prenex normal form (all quantifiers at the front) with m alternations between existential and universal quantifiers applied to a formula with bounded quantifiers only. Formally a formula \\phi(s) in the language of Peano arithmetic is a \\Sigma^{0}_m formula if it is of the form :\\left(\\exists n^1_1\\exists n^1_2\\cdots\\exists n^1_{j_1}\\right)\\left(\\forall n^2_1 \\cdots \\forall n^2_{j_2}\\right)\\left(\\exists n^3_1\\cdots\\right)\\cdots\\left(Q n^m_1 \\cdots \\right)\\rho(n^1_1,\\ldots n^m_{j_m},x_1,\\ldots,x_k) where \\rho contains only bounded quantifiers and Q is \\forall if m is even and \\exists if m is odd. A set of natural numbers A is said to be \\Sigma^0_m if it is definable by a \\Sigma^0_m formula, that is, if there is a \\Sigma^0_m formula \\phi(s) such that each number n is in A if and only if \\phi(n) holds. It is known that if a set is \\Sigma^0_m then it is \\Sigma^0_n for any n > m, but for each m there is a \\Sigma^0_{m+1} set that is not \\Sigma^0_m. Thus the number of quantifier alternations required to define a set gives a measure of the complexity of the set. Post's theorem uses the relativized arithmetical hierarchy as well as the unrelativized hierarchy just defined. A set A of natural numbers is said to be \\Sigma^0_m relative to a set B, written \\Sigma^{0,B}_m, if A is definable by a \\Sigma^0_m formula in an extended language that includes a predicate for membership in B. While the arithmetical hierarchy measures definability of sets of natural numbers, Turing degrees measure the level of uncomputability of sets of natural numbers. A set A is said to be Turing reducible to a set B, written A \\leq_T B, if there is an oracle Turing machine that, given an oracle for B, computes the characteristic function of A. The Turing jump of a set A is a form of the Halting problem relative to A. Given a set A, the Turing jump A' is the set of indices of oracle Turing machines that halt on input 0 when run with oracle A. It is known that every set A is Turing reducible to its Turing jump, but the Turing jump of a set is never Turing reducible to the original set. Post's theorem uses finitely iterated Turing jumps. For any set A of natural numbers, the notation A^{(n)} indicates the n-fold iterated Turing jump of A. Thus A^{(0)} is just A, and A^{(n+1)} is the Turing jump of A^{(n)}. == Post's theorem and corollaries == Post's theorem establishes a close connection between the arithmetical hierarchy and the Turing degrees of the form \\emptyset^{(n)}, that is, finitely iterated Turing jumps of the empty set. (The empty set could be replaced with any other computable set without changing the truth of the theorem.) Post's theorem states: #A set B is \\Sigma^0_{n+1} if and only if B is recursively enumerable by an oracle Turing machine with an oracle for \\emptyset^{(n)}, that is, if and only if B is \\Sigma^{0,\\emptyset^{(n)}}_1. #The set \\emptyset^{(n)} is \\Sigma^0_n-complete for every n > 0. This means that every \\Sigma^0_n set is many-one reducible to \\emptyset^{(n)}. Post's theorem has many corollaries that expose additional relationships between the arithmetical hierarchy and the Turing degrees. These include: #Fix a set C. A set B is \\Sigma^{0,C}_{n+1} if and only if B is \\Sigma^{0,C^{(n)}}_1. This is the relativization of the first part of Post's theorem to the oracle C. #A set B is \\Delta_{n+1} if and only if B \\leq_T \\emptyset^{(n)}. More generally, B is \\Delta^C_{n+1} if and only if B \\leq_T C^{(n)}. #A set is defined to be arithmetical if it is \\Sigma^0_n for some n. Post's theorem shows that, equivalently, a set is arithmetical if and only if it is Turing reducible to \\emptyset^{(m)} for some m. == Proof of Post's theorem == ===Formalization of Turing machines in first-order arithmetic=== The operation of a Turing machine T on input n can be formalized logically in first-order arithmetic. For example, we may use symbols A_k, B_k, and C_k for the tape configuration, machine state and location along the tape after k steps, respectively. T's transition system determines the relation between (A_k,B_k,C_k) and (A_{k+1},B_{k+1},C_{k+1}); their initial values (for k=0) are the input, the initial state and zero, respectively. The machine halts if and only if there is a number k such that B_k is the halting state. The exact relation depends on the specific implementation of the notion of Turing machine (e.g. their alphabet, allowed mode of motion along the tape, etc.) In case T halts at time n_1, the relation between (A_k,B_k,C_k) and (A_{k+1},B_{k+1},C_{k+1}) must be satisfied only for k bounded from above by n_1. Thus there is a formula \\varphi(n,n_1) in first-order arithmetic with no unbounded quantifiers, such that T halts on input n at time n_1 at most if and only if \\varphi(n,n_1) is satisfied. ===Implementation example=== For example, for a prefix-free Turing machine with binary alphabet and no blank symbol, we may use the following notations: *A_k is the 1-ary symbol for the configuration of the whole tape after k steps (which we may write as a number with LSB first, the value of the m-th location on the tape being its m-th least significant bit). In particular A_0 is the initial configuration of the tape, which corresponds the input to the machine. *B_k is the 1-ary symbol for the Turing machine state after k steps. In particular, B_0=q_I, the initial state of the Turing machine. *C_k is the 1-ary symbol for the Turing machine location on the tape after k steps. In particular C_0=0. * M(q,b) is the transition function of the Turing machine, written as a function from a doublet (machine state, bit read by the machine) to a triplet (new machine state, bit written by the machine, +1 or -1 machine movement along the tape). *bit(j,m) is the j-th bit of a number m. This can be written as a first-order arithmetic formula with no unbounded quantifiers. For a prefix-free Turing machine we may use, for input n, the initial tape configuration t(n)= cat(2^{ceil(log_2 n)}-1,0,n) where cat stands for concatenation; thus t(n) is a \\log(n)-length string of 1-s followed by 0 and then by n. The operation of the Turing machine at the first n_1 steps can thus be written as the conjunction of the initial conditions and the following formulas, quantified over k for all k: *(B_{k+1}, bit(C_k ,A_{k+1}), D) = M(B_k, bit(C_k ,A_k)). Since M has a finite domain, this can be replaced by a first-order quantifier- free arithmetic formula. The exact formula obviously depends on M. *C_{k+1} = C_k+D *\\forall j: j e C_k \\rightarrow bit(j ,A_{k+1}) = bit(j ,A_k). Note that at the first n_1 steps, T never arrives at a location along the tape greater than n_1. Thus the universal quantifier over j can be bounded by n_1+1, as bits beyond this location have no relevance for the machine's operation. T halts on input n at time n_1 at most if and only if \\varphi(n,n_1) is satisfied, where: :\\begin{align}\\varphi(n,n_1) =& (A_0=t(n)) \\land (B_0=q_I) \\land (C_0=0) \\land (B_{n_1}=q_H)\\\\\\ &\\land \\forall k This is a first-order arithmetic formula with no unbounded quantifiers, i.e. it is in \\Sigma^0_0. ===Recursively enumerable sets=== Let S be a set that can be recursively enumerated by a Turing machine. Then there is a Turing machine T that for every n in S, T halts when given n as an input. This can be formalized by the first-order arithmetical formula presented above. The members of S are the numbers n satisfying the following formula: \\exists n_1:\\varphi(n,n_1) This formula is in \\Sigma^0_1. Therefore, S is in \\Sigma^0_1. Thus every recursively enumerable set is in \\Sigma^0_1. The converse is true as well: for every formula \\varphi(n) in \\Sigma^0_1 with k existential quantifiers, we may enumerate the k-tuples of natural numbers and run a Turing machine that goes through all of them until it finds the formula is satisfied. This Turing machine halts on precisely the set of natural numbers satisfying \\varphi(n), and thus enumerates its corresponding set. ===Oracle machines=== Similarly, the operation of an oracle machine T with an oracle O that halts after at most n_1 steps on input n can be described by a first-order formula \\varphi_O(n,n_1), except that the formula \\varphi_1(n,n_1) now includes: * A new predicate, O_m, giving the oracle answer. This predicate must satisfy some formula to be discussed below. * An additional tape - the oracle tape - on which T has to write the number m for every call O(m) to the oracle; writing on this tape can be logically formalized in a similar manner to writing on the machine's tape. Note that an oracle machine that halts after at most n_1 steps has time to write at most n_1 digits on the oracle tape. So the oracle can only be called with numbers m satisfying m<2^{n_1}. If the oracle is for a decision problem, O_m is always \"Yes\" or \"No\", which we may formalize as 0 or 1. Suppose the decision problem itself can be formalized by a first-order arithmetic formula \\psi^O(m). Then T halts on n after at most n_1 steps if and only if the following formula is satisfied: \\varphi_O(n,n_1) =\\forall m<2^{n_1}:((\\psi^O(m)\\rightarrow (O_m=1)) \\land(\\lnot\\psi^O(m)\\rightarrow (O_m=0))) \\land {\\varphi_O}_1(n,n_1) where {\\varphi_O}_1(n,n_1) is a first-order formula with no unbounded quantifiers. ===Turing jump=== If O is an oracle to the halting problem of a machine T', then \\psi^O(m) is the same as \"there exists m_1 such that T' starting with input m is at the halting state after m_1 steps\". Thus: \\psi^O(m) = \\exists m_1: \\psi_H(m,m_1) where \\psi_H(m,m_1) is a first-order formula that formalizes T'. If T' is a Turing machine (with no oracle), \\psi_H(m,m_1) is in \\Sigma^0_0 = \\Pi^0_0 (i.e. it has no unbounded quantifiers). Since there is a finite number of numbers m satisfying m<2^{n_1}, we may choose the same number of steps for all of them: there is a number m_1, such that T' halts after m_1 steps precisely on those inputs m<2^{n_1} for which it halts at all. Moving to prenex normal form, we get that the oracle machine halts on input n if and only if the following formula is satisfied: \\varphi(n) =\\exists n_1\\exists m_1 \\forall m_2 :(\\psi_H(m,m_2)\\rightarrow (O_m=1)) \\land(\\lnot\\psi_H(m,m_1)\\rightarrow (O_m=0))) \\land {\\varphi_O}_1(n,n_1) (informally, there is a \"maximal number of steps\"m_1 such every oracle that does not halt within the first m_1 steps does not stop at all; however, for everym_2, each oracle that halts after m_2 steps does halt). Note that we may replace both n_1 and m_1 by a single number - their maximum - without changing the truth value of \\varphi(n). Thus we may write: \\varphi(n) =\\exists n_1 \\forall m_2 :(\\psi_H(m,m_2)\\rightarrow (O_m=1)) \\land(\\lnot\\psi_H(m,n_1)\\rightarrow (O_m=0))) \\land {\\varphi_O}_1(n,n_1) For the oracle to the halting problem over Turing machines, \\psi_H(m,m_1) is in \\Pi^0_0 and \\varphi(n) is in \\Sigma^0_2. Thus every set that is recursively enumerable by an oracle machine with an oracle for \\emptyset ^{(1)}, is in \\Sigma^0_2. The converse is true as well: Suppose \\varphi(n) is a formula in \\Sigma^0_2 with k_1 existential quantifiers followed by k_2 universal quantifiers. Equivalently, \\varphi(n) has k_1> existential quantifiers followed by a negation of a formula in \\Sigma^0_1; the latter formula can be enumerated by a Turing machine and can thus be checked immediately by an oracle for \\emptyset ^{(1)}. We may thus enumerate the k_1-tuples of natural numbers and run an oracle machine with an oracle for \\emptyset ^{(1)} that goes through all of them until it finds a satisfaction for the formula. This oracle machine halts on precisely the set of natural numbers satisfying \\varphi(n), and thus enumerates its corresponding set. ===Higher Turing jumps=== More generally, suppose every set that is recursively enumerable by an oracle machine with an oracle for \\emptyset ^{(p)} is in \\Sigma^0_{p+1}. Then for an oracle machine with an oracle for \\emptyset ^{(p+1)}, \\psi^O(m) = \\exists m_1: \\psi_H(m,m_1) is in \\Sigma^0_{p+1}. Since \\psi^O(m) is the same as \\varphi(n) for the previous Turing jump, it can be constructed (as we have just done with \\varphi(n) above) so that \\psi_H(m,m_1) in \\Pi^0_p. After moving to prenex formal form the new \\varphi(n) is in \\Sigma^0_{p+2}. By induction, every set that is recursively enumerable by an oracle machine with an oracle for \\emptyset ^{(p)}, is in \\Sigma^0_{p+1}. The other direction can be proven by induction as well: Suppose every formula in \\Sigma^0_{p+1} can be enumerated by an oracle machine with an oracle for \\emptyset ^{(p)}. Now Suppose \\varphi(n) is a formula in \\Sigma^0_{p+2} with k_1 existential quantifiers followed by k_2 universal quantifiers etc. Equivalently, \\varphi(n) has k_1> existential quantifiers followed by a negation of a formula in \\Sigma^0_{p+1}; the latter formula can be enumerated by an oracle machine with an oracle for \\emptyset ^{(p)} and can thus be checked immediately by an oracle for \\emptyset ^{(p+1)}. We may thus enumerate the k_1-tuples of natural numbers and run an oracle machine with an oracle for \\emptyset ^{(p+1)} that goes through all of them until it finds a satisfaction for the formula. This oracle machine halts on precisely the set of natural numbers satisfying \\varphi(n), and thus enumerates its corresponding set. == References == Rogers, H. The Theory of Recursive Functions and Effective Computability, MIT Press. ; Soare, R. Recursively enumerable sets and degrees. Perspectives in Mathematical Logic. Springer-Verlag, Berlin, 1987. Category:Theorems in the foundations of mathematics Category:Computability theory Category:Mathematical logic hierarchies",
 "title": "Post's theorem"
}