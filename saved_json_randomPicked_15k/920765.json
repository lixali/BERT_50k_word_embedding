{
 "id": "920765",
 "text": "thumb|`stat` command line is a Unix system call that returns file attributes about an inode. The semantics of vary between operating systems. As an example, Unix command uses this system call to retrieve information on files that includes: * atime: time of last access () * mtime: time of last modification () * ctime: time of last status change () `stat` appeared in Version 1 Unix. It is among the few original Unix system calls to change, with Version 4's addition of group permissions and larger file size. ==stat() functions== The C POSIX library header , found on POSIX and other Unix-like operating systems, declares the `stat()` functions, as well as related functions called `fstat()` and `lstat()`. The functions take a `struct stat` buffer argument, which is used to return the file attributes. On success, the functions return zero, and on error, −1 is returned and errno is set appropriately. The `stat()` and `lstat()` functions take a filename argument. If the file is a symbolic link, `stat()` returns attributes of the eventual target of the link, while `lstat()` returns attributes of the link itself. The `fstat()` function takes a file descriptor argument instead, and returns attributes of the file that it identifies. The family of functions was extended to implement large file support. Functions named `stat64()`, `lstat64()` and `fstat64()` return attributes in a `struct stat64` structure, which represents file sizes with a 64-bit type, allowing the functions to work on files 2 GiB and larger (up to 8 EiB). When the `_FILE_OFFSET_BITS` macro is defined to 64, these 64-bit functions are available under the original names. The functions are defined as: int stat(const char *filename, struct stat *buf); int lstat(const char *filename, struct stat *buf); int fstat(int filedesc, struct stat *buf); ==stat structure== This structure is defined in header file as follows, although implementations are free to define additional fields: struct stat { mode_t st_mode; ino_t st_ino; dev_t st_dev; dev_t st_rdev; nlink_t st_nlink; uid_t st_uid; gid_t st_gid; off_t st_size; struct timespec st_atim; struct timespec st_mtim; struct timespec st_ctim; blksize_t st_blksize; blkcnt_t st_blocks; }; POSIX.1 does not require `st_rdev`, `st_blocks` and `st_blksize` members; these fields are defined as part of XSI option in the Single Unix Specification. In older versions of POSIX.1 standard, the time-related fields were defined as `st_atime`, `st_mtime` and `st_ctime`, and were of type `time_t`. Since the 2008 version of the standard, these fields were renamed to `st_atim`, `st_mtim` and `st_ctim`, respectively, of type struct `timespec`, since this structure provides a higher resolution time unit. For the sake of compatibility, implementations can define the old names in terms of the `tv_sec` member of `struct timespec`. For example, `st_atime` can be defined as `st_atim.tv_sec`. The `struct stat` structure includes at least the following members: * `st_dev` identifier of device containing file * `st_ino` inode number * `st_mode` protection mode; see also Unix permissions * `st_nlink` reference count of hard links * `st_uid` user identifier of owner * `st_gid` group identifier of owner * `st_rdev` device identifier (if special file) * `st_size` total file size, in bytes * `st_atime` time of last access * `st_mtime` time of last modification * `st_ctime` time of last status change * `st_blksize` preferred block size for file system I/O, which can depend upon both the system and the type of file system * `st_blocks` number of blocks allocated in multiples of `DEV_BSIZE` (usually 512 bytes). The `st_mode` field is a bit field. It combines the file access modes and also indicates any special file type. There are many macros to work with the different mode flags and file types. == Criticism of atime == Reading a file changes its eventually requiring a disk write, which has been criticized as it is inconsistent with a read only file system. File system cache may significantly reduce this activity to one disk write per cache flush. Linux kernel developer Ingo Molnár publicly criticized the concept and performance impact of atime in 2007,Kernel Trap: Linux: Replacing atime With relatime, by Jeremy, August 7, 2007Once upon atime, LWN, by Jonathan Corbet, August 8, 2007 and in 2009, the mount option had become the default, which addresses this criticism.Linux kernel 2.6.30, Linux Kernel Newbies The behavior behind the mount option offers sufficient performance for most purposes and should not break any significant applications, as it has been extensively discussed.That massive filesystem thread, LWN, by Jonathan Corbet, March 31, 2009 Initially, only updated atime if atime < mtime or atime < ctime; that was subsequently modified to update atimes that were 24 hours old or older, so that and Debian's popularity counter (popcon) would behave properly.Relatime Recap, Valerie Aurora Current versions of the Linux kernel support four mount options, which can be specified in fstab: * (formerly , and formerly the default; as of 2.6.30) always update atime, which conforms to the behavior defined by POSIX * (\"relative atime\", introduced in 2.6.20 and the default as of 2.6.30) only update atime under certain circumstances: if the previous atime is older than the mtime or ctime, or the previous atime is over 24 hours in the past * never update atime of directories, but do update atime of other files * never update atime of any file or directory; implies ; highest performance, but least compatible * update atime according to specific circumstances laid out below Current versions of Linux, macOS, Solaris, FreeBSD, and NetBSD support a mount option in /etc/fstab, which causes the atime field never to be updated. Turning off atime updating breaks POSIX compliance, and some applications, such as mbox-driven \"new mail\" notifications,http://www.mail-archive.com/mutt-users@mutt.org/msg24912.html \"the shell's $MAIL monitor ... depends on atime, pronouncing new email with atime($MAIL) < mtime($MAIL)\" and some file usage watching utilities, notably tmpwatch. The option on OpenBSD behaves more like Linux . Version 4.0 of the Linux kernel mainline, which was released on April 12, 2015, introduced the new mount option . It allows POSIX-style atime updates to be performed in- memory and flushed to disk together with some non-time-related I/O operations on the same file; atime updates are also flushed to disk when some of the sync system calls are executed, or before the file's in-memory inode is evicted from the filesystem cache. Additionally, it is possible to configure for how long atime modifications can remain unflushed. That way, lazytime retains POSIX compatibility while offering performance improvements. == ctime == It is tempting to believe that originally meant creation time; however, while early Unix did have modification and creation times, the latter was changed to be access time before there was any C structure in which to call anything . The file systems retained just the access time () and modification time () through 6th edition Unix. The timestamp was added in the file system restructuring that occurred with 7th edition Unix, and has always referred to inode change time. It is updated any time file metadata stored in the inode changes, such as file permissions, file ownership, and creation and deletion of hard links. In some implementations, is affected by renaming a file: Both original Unix, which implemented a renaming by making a link (updating ) and then unlinking the old name (updating again) and modern Linux tend to do this. Unlike and , cannot be set to an arbitrary value with , as used by the utility, for example. Instead, when is used, or for any other change to the inode other than an update to caused by accessing the file, the value is set to the current time. == Time granularity == * provides times accurate to one second. * Some filesystems provide finer granularity. Solaris 2.1 introduced a microsecond resolution with UFS in 1992 and a nanosecond resolution with ZFS. * In Linux kernels 2.5.48 and above, the stat structure supports nanosecond resolution for the three file timestamp fields. These are exposed as additional fields in the stat structure. * The resolution of create time on FAT filesystem is 10 milliseconds, while resolution of its write time is two seconds, and access time has a resolution of one day thus it acts as the access date.MSDN: File Times == Example == #include #include #include #include #include #include #include int main(int argc, char *argv[]) { struct stat sb; struct passwd *pwuser; struct group *grpnam; if (argc < 2) { fprintf(stderr, \"Usage: %s: file ... \", argv[0]); exit(EXIT_FAILURE); } for (int i = 1; i < argc; i++) { if (-1 == stat(argv[i], &sb;)) { perror(\"stat()\"); exit(EXIT_FAILURE); } if (NULL == (pwuser = getpwuid(sb.st_uid))) { perror(\"getpwuid()\"); exit(EXIT_FAILURE); } if (NULL == (grpnam = getgrgid(sb.st_gid))) { perror(\"getgrgid()\"); exit(EXIT_FAILURE); } printf(\"%s: \", argv[i]); printf(\"\\tinode: %u \", sb.st_ino); printf(\"\\towner: %u (%s) \", sb.st_uid, pwuser->pw_name); printf(\"\\tgroup: %u (%s) \", sb.st_gid, grpnam->gr_name); printf(\"\\tperms: %o \", sb.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO)); printf(\"\\tlinks: %d \", sb.st_nlink); printf(\"\\tsize: %ld \", sb.st_size); /* you may use %lld */ printf(\"\\tatime: %s\", ctime(&sb.st;_atim.tv_sec)); printf(\"\\tmtime: %s\", ctime(&sb.st;_mtim.tv_sec)); printf(\"\\tctime: %s\", ctime(&sb.st;_ctim.tv_sec)); printf(\" \"); } return 0; } ==References== * IEEE Std 1003.1, 2004, documentation for fstat(2). Retrieved 2012-06-07. * stat(2) Linux man page. Retrieved 2012-06-07. * ==External links == * An example showing how to use stat() * stat() in Perl * stat() in PHP * atime and relatime Category:C POSIX library Category:POSIX Category:Unix file system- related software Category:System calls",
 "title": "Stat (system call)"
}