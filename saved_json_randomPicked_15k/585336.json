{
 "id": "585336",
 "text": "This is a list of operators in the C and C++ programming languages. All the operators listed exist in C++; the column \"Included in C\", states whether an operator is also present in C. Note that C does not support operator overloading. When not overloaded, for the operators `&&`, `||`, and `,` (the comma operator), there is a sequence point after the evaluation of the first operand. C++ also contains the type conversion operators `const_cast`, `static_cast`, `dynamic_cast`, and `reinterpret_cast`. The formatting of these operators means that their precedence level is unimportant. Most of the operators available in C and C++ are also available in other C-family languages such as C#, D, Java, Perl, and PHP with the same precedence, associativity, and semantics. ==Table== For the purposes of these tables, `a`, `b`, and `c` represent valid values (literals, values from variables, or return value), object names, or lvalues, as appropriate. `R`, `S` and `T` stand for any type(s), and `K` for a class type or enumerated type. ===Arithmetic operators=== All arithmetic operators exist in C and C++ and can be overloaded in C++. {| class=\"wikitable\" style=\"width:100%\" ! colspan=\"2\" rowspan=\"2\" | Operator name ! rowspan=\"2\" | Syntax ! colspan=\"2\" | C++ prototype examples |- ! As member of K ! Outside class definitions |- | colspan=\"2\" | Addition | style=\"text-align:center;\" | | | |- | colspan=\"2\" | Subtraction | style=\"text-align:center;\" | `a - b` | | |- | colspan=\"2\" | Unary plus (integer promotion) | style=\"text-align:center;\" | `+a` | | |- | colspan=\"2\" | Unary minus (additive inverse) | style=\"text-align:center;\" | `-a` | | |- | colspan=\"2\" | Multiplication | style=\"text-align:center;\" | `a * b` | | |- | colspan=\"2\" | Division | style=\"text-align:center;\" | `a / b` | | |- | colspan=\"2\" | Modulo (integer remainder) | style=\"text-align:center;\" | `a % b` | | |- | width=\"15%\" rowspan=\"3\" | Increment | width=\"8%\" | Prefix | width=\"11%\" align=\"center\" | `++a` | width=\"25%\" | | width=\"25%\" | |- | rowspan=\"2\" | Postfix | rowspan=\"2\" style=\"text-align:center;\" | `a++` | | |- | colspan=\"2\" style=\"font-size:smaller;\" | Note: C++ uses the unnamed dummy- parameter to differentiate between prefix and postfix increment operators. |- | rowspan=\"3\" | Decrement | | Prefix | style=\"text-align:center;\" | `--a` | | |- | rowspan=\"2\" | Postfix | rowspan=\"2\" style=\"text-align:center;\" | `a--` | | |- | colspan=\"2\" style=\"font-size:smaller;\" | Note: C++ uses the unnamed dummy-parameter to differentiate between prefix and postfix decrement operators. |} ===Comparison operators/relational operators=== All comparison operators can be overloaded in C++. {| class=\"wikitable\" style=\"width:100%\" ! colspan=\"2\" rowspan=\"2\" | Operator name ! rowspan=\"2\" | Syntax ! rowspan=\"2\" | Included in C ! colspan=\"2\" | Prototype examples |- ! As member of K ! Outside class definitions |- | width=\"23%\" colspan=\"2\" | Equal to | width=\"11%\" align=\"center\" | `a == b` | width=\"8%\" | width=\"25%\" | | width=\"25%\" | |- | colspan=\"2\" | Not equal to | style=\"text-align:center;\" | `a != b` || | | |- | colspan=\"2\" | Greater than | style=\"text-align:center;\" | `a > b` || | | |- | colspan=\"2\" | Less than | style=\"text-align:center;\" | `a < b` || | | |- | colspan=\"2\" | Greater than or equal to | style=\"text-align:center;\" | `a >= b` || | | |- | colspan=\"2\" | Less than or equal to | style=\"text- align:center;\" | `a <= b` || | | |- | colspan=\"2\" rowspan=\"2\" | Three-way comparison | rowspan=\"2\" style=\"text-align:center;\" | `a <=> b` || rowspan=\"2\" | | |- | colspan=\"2\" style=\"font-size:smaller;\" | The operator has a total of 3 possible return types: `std::weak_ordering`, `std::strong_ordering` and `std::partial_ordering` to which they all are convertible to. |} ===Logical operators=== All logical operators exist in C and C++ and can be overloaded in C++, albeit the overloading of the logical AND and logical OR is discouraged, because as overloaded operators they behave as ordinary function calls, which means that both of their operands are evaluated, so they lose their well-used and expected short-circuit evaluation property. {| class=\"wikitable\" style=\"width:100%\" ! colspan=\"2\" rowspan=\"2\" | Operator name ! rowspan=\"2\" | Syntax ! colspan=\"2\" | C++ prototype examples |- ! As member of K ! Outside class definitions |- | width=\"23%\" colspan=\"2\" | Logical negation (NOT) | width=\"11%\" align=\"center\" | `!a` `not a` | width=\"25%\" | | width=\"25%\" | |- | colspan=\"2\" | Logical AND | style=\"text-align:center;\" | `a && b` | | |- | colspan=\"2\" | Logical OR | style=\"text-align:center;\" | `a || b` `a or b` | | |} ===Bitwise operators=== All bitwise operators exist in C and C++ and can be overloaded in C++. {| class=\"wikitable\" style=\"width:100%\" ! colspan=\"2\" rowspan=\"2\" | Operator name ! rowspan=\"2\" | Syntax ! colspan=\"2\" | Prototype examples |- ! As member of K ! Outside class definitions |- | width=\"23%\" colspan=\"2\" | Bitwise NOT | width=\"11%\" align=\"center\" | `~a` `compl a` | width=\"25%\" | | width=\"25%\" | |- | colspan=\"2\" | Bitwise AND | style=\"text-align:center;\" | `a & b` | | |- | colspan=\"2\" | Bitwise OR | style=\"text-align:center;\" | `a | b` `a bitor b` | | |- | colspan=\"2\" | Bitwise XOR | style=\"text-align:center;\" | `a ^ b` `a xor b` | | |- | colspan=\"2\" | Bitwise left shift | style=\"text- align:center;\" | `a << b` | | |- | colspan=\"2\" | Bitwise right shift | style=\"text-align:center;\" | `a >> b` | | |} ===Assignment operators=== All assignment expressions exist in C and C++ and can be overloaded in C++. For the given operators the semantic of the built-in combined assignment expression `a ⊚= b` is equivalent to `a = a ⊚ b`, except that `a` is evaluated only once. {| class=\"wikitable\" style=\"width:100%\" ! rowspan=\"2\" | Operator name ! rowspan=\"2\" | Syntax ! colspan=\"2\" | C++ prototype examples |- ! As member of K ! Outside class definitions |- ! Direct assignment | style=\"text- align:center;\" | | | |- ! Addition assignment | align=\"center\" | `a += b` | | |- ! Subtraction assignment | style=\"text-align:center;\" | `a -= b` | | |- ! Multiplication assignment | style=\"text-align:center;\" | `a *= b` | | |- ! Division assignment | style=\"text-align:center;\" | `a /= b` | | |- ! Modulo assignment | style=\"text-align:center;\" | `a %= b` | | |- ! Bitwise AND assignment | style=\"text-align:center;\" | `a &= b` | | |- ! Bitwise OR assignment | style=\"text-align:center;\" | `a |= b` `a or_eq b` | | |- ! Bitwise XOR assignment | style=\"text-align:center;\" | `a ^= b` `a xor_eq b` | | |- ! Bitwise left shift assignment | style=\"text- align:center;\" | `a <<= b` | | |- ! Bitwise right shift assignment | style=\"text-align:center;\" | `a >>= b` | | |} ===Member and pointer operators=== {| class=\"wikitable\" style=\"width:100%\" ! colspan=\"2\" rowspan=\"2\" | Operator name ! rowspan=\"2\" | Syntax ! rowspan=\"2\" | Can overload in C++ ! rowspan=\"2\" | Included in C ! colspan=\"2\" | C++ prototype examples |- ! As member of K ! Outside class definitions |- | width=\"23%\" colspan=\"2\" | Subscript | width=\"11%\" align=\"center\" | `a[b]` | width=\"8%\" | width=\"8%\" | | width=\"25%\" |- | colspan=\"2\" | Indirection (\"object pointed to by a\") | style=\"text-align:center;\" | `*a` || || | | |- | colspan=\"2\" | Address-of (\"address of a\") | style=\"text-align:center;\" | `&a;` || || | | |- | colspan=\"2\" | Structure dereference (\"member b of object pointed to by a\") | style=\"text-align:center;\" | `a->b` || || | | |- | colspan=\"2\" | Structure reference (\"member b of object a\") | style=\"text-align:center;\" | `a.b` || || | colspan=\"2\" |- | colspan=\"2\" | Member selected by pointer-to-member b of object pointed to by a | style=\"text-align:center;\" | `a->*b` || || | | |- | colspan=\"2\" | Member of object a selected by pointer-to-member b | style=\"text-align:center;\" | `a.*b` || || | colspan=\"2\" |} ===Other operators=== {| class=\"wikitable\" style=\"width:100%\" ! colspan=\"2\" rowspan=\"2\" | Operator name ! rowspan=\"2\" | Syntax ! rowspan=\"2\" | Can overload in C++ ! rowspan=\"2\" | Included in C ! colspan=\"2\" | Prototype examples |- ! As member of K ! Outside class definitions |- | width=\"12%\" colspan=\"2\" | Function call See Function object. | width=\"22%\" align=\"center\" | `a(a1, a2)` | width=\"8%\" | width=\"8%\" | | width=\"25%\" |- | colspan=\"2\" | Comma | style=\"text- align:center;\" | `a, b` || || | | |- | colspan=\"2\" | Ternary conditional | style=\"text-align:center;\" | `a ? b : c` || || | colspan=\"2\" |- | colspan=\"2\" | Scope resolution | style=\"text-align:center;\" | `a::b` || || | colspan=\"2\" |- | colspan=\"2\" | User-defined literals since C++11 | style=\"text-align: center;\" | `\"a\"_b` || || | | |- | colspan=\"2\" | Sizeof | style=\"text-align:center;\" | `sizeof(a)` `sizeof(type)` || || | colspan=\"2\" |- | colspan=\"2\" | Size of parameter pack since C++11 | style=\"text-align:center;\" | `sizeof...(Args)` || || | colspan=\"2\" |- | colspan=\"2\" | Alignof since C++11 | style=\"text-align:center;\" | `alignof(type)` or `_Alignof(type)` || || | colspan=\"2\" |- | colspan=\"2\" | Type identification | style=\"text-align:center;\" | `typeid(a)` `typeid(type)` || || | colspan=\"2\" |- | colspan=\"2\" | Conversion (C-style cast) | style=\"text-align:center;\" | `(type)a` || || | | |- | colspan=\"2\" | Conversion | style=\"text-align:center;\" | `type(a)` || || | style=font- size:smaller colspan=\"2\" | Note: behaves like const_cast/static_cast/reinterpret_castExplicit type conversion in C++ |- | rowspan=\"2\" colspan=\"2\" | static_cast conversion | rowspan=\"2\" style=\"text- align:center;\" | `static_cast(a)` || rowspan=\"2\" || rowspan=\"2\" | since C++11 | |- | colspan=\"2\" style=\"font-size:smaller;\" | Note: for user- defined conversions, the return type implicitly and necessarily matches the operator name. |- | colspan=\"2\" | dynamic cast conversion | style=\"text- align:center;\" | `dynamic_cast(a)` || || | colspan=\"2\" |- | colspan=\"2\" | const_cast conversion | style=\"text-align:center;\" | `const_cast(a)` || || | colspan=\"2\" |- | colspan=\"2\" | reinterpret_cast conversion | style=\"text- align:center;\" | `reinterpret_cast(a)` || || | colspan=\"2\" |- | colspan=\"2\" | Allocate storage | style=\"text-align:center;\" | `new type` || || | | |- | colspan=\"2\" | Allocate storage (array) | style=\"text-align:center;\" | `new type[n]` || || | | |- | colspan=\"2\" | Deallocate storage | style=\"text- align:center;\" | `delete a` || || | | |- | colspan=\"2\" | Deallocate storage (array) | style=\"text-align:center;\" | `delete[] a` || || | | |- | colspan=\"2\" | Exception check since C++11 | style=\"text-align:center;\" | `noexcept(a)` || || | colspan=\"2\" |} Notes: ==Operator precedence== The following is a table that lists the precedence and associativity of all the operators in the C and C++ languages. Operators are listed top to bottom, in descending precedence. Descending precedence refers to the priority of the grouping of operators and operands. Considering an expression, an operator which is listed on some row will be grouped prior to any operator that is listed on a row further below it. Operators that are in the same cell (there may be several rows of operators listed in a cell) are grouped with the same precedence, in the given direction. An operator's precedence is unaffected by overloading. The syntax of expressions in C and C++ is specified by a phrase structure grammar. The table given here has been inferred from the grammar. For the ISO C 1999 standard, section 6.5.6 note 71 states that the C grammar provided by the specification defines the precedence of the C operators, and also states that the operator precedence resulting from the grammar closely follows the specification's section ordering: \"The [C] syntax [i.e., grammar] specifies the precedence of operators in the evaluation of an expression, which is the same as the order of the major subclauses of this subclause, highest precedence first.\" A precedence table, while mostly adequate, cannot resolve a few details. In particular, note that the ternary operator allows any arbitrary expression as its middle operand, despite being listed as having higher precedence than the assignment and comma operators. Thus `a ? b, c : d` is interpreted as `a ? (b, c) : d`, and not as the meaningless `(a ? b), (c : d)`. So, the expression in the middle of the conditional operator (between `?` and `:`) is parsed as if parenthesized. Also, note that the immediate, unparenthesized result of a C cast expression cannot be the operand of `sizeof`. Therefore, `sizeof (int) * x` is interpreted as `(sizeof(int)) * x` and not `sizeof ((int) * x)`. {| class=\"wikitable\" |- ! style=\"text-align: left\" | Precedence ! style=\"text-align: left\" | Operator ! style=\"text-align: left\" | Description ! style=\"text-align: left\" | Associativity |- ! 1 highest | `::` | Scope resolution (C++ only) | None |- ! rowspan=11| 2 | style=\"border-bottom-style: none\" | `++` | style=\"border-bottom-style: none\" | Postfix increment | style=\"vertical-align: top\" rowspan=\"11\" | Left-to-right |- | style=\"border-bottom-style: none; border-top-style: none\" | `--` | style=\"border-bottom-style: none; border-top-style: none\" | Postfix decrement |- | style=\"border-bottom-style: none; border-top-style: none\" | `()` | style=\"border-bottom-style: none; border-top-style: none\" | Function call |- | style=\"border-bottom-style: none; border-top-style: none\" | `[]` | style=\"border-bottom-style: none; border-top-style: none\" | Array subscripting |- | style=\"border-bottom-style: none; border-top-style: none\" | `.` | style=\"border-bottom-style: none; border-top-style: none\" | Element selection by reference |- | style=\"border-bottom-style: none; border-top-style: none\" | `->` | style=\"border-bottom-style: none; border-top-style: none\" | Element selection through pointer |- | style=\"border-bottom-style: none; border-top- style: none\" | `typeid()` | style=\"border-bottom-style: none; border-top- style: none\" | Run-time type information (C++ only) (see typeid) |- | style=\"border-bottom-style: none; border-top-style: none\" | `const_cast` | style=\"border-bottom-style: none; border-top-style: none\" | Type cast (C++ only) (see const_cast) |- | style=\"border-bottom-style: none; border-top- style: none\" | `dynamic_cast` | style=\"border-bottom-style: none; border-top- style: none\" | Type cast (C++ only) (see dynamic cast) |- | style=\"border- bottom-style: none; border-top-style: none\" | `reinterpret_cast` | style=\"border-bottom-style: none; border-top-style: none\" | Type cast (C++ only) (see reinterpret_cast) |- | style=\"border-top-style: none\" | `static_cast` | style=\"border-top-style: none\" | Type cast (C++ only) (see static_cast) |- ! rowspan=\"13\" | 3 | style=\"border-bottom-style: none\" | `++` | style=\"border-bottom-style: none\" | Prefix increment | rowspan=\"13\" style=\"vertical-align: top\" | Right-to-left |- | style=\"border-bottom-style: none; border-top-style: none\" | `--` | style=\"border-bottom-style: none; border-top-style: none\" | Prefix decrement |- | style=\"border-bottom-style: none; border-top-style: none\" | `+` | style=\"border-bottom-style: none; border-top-style: none\" | Unary plus |- | style=\"border-bottom-style: none; border-top-style: none\" | `-` | style=\"border-bottom-style: none; border-top- style: none\" | Unary minus |- | style=\"border-bottom-style: none; border-top- style: none\" | `!` | style=\"border-bottom-style: none; border-top-style: none\" | Logical NOT |- | style=\"border-bottom-style: none; border-top-style: none\" | `~` | style=\"border-bottom-style: none; border-top-style: none\" | Bitwise NOT (One's Complement) |- | style=\"border-bottom-style: none; border-top-style: none\" | `(type)` | style=\"border-bottom-style: none; border-top-style: none\" | Type cast |- | style=\"border-bottom-style: none; border-top-style: none\" | `*` | style=\"border-bottom-style: none; border-top-style: none\" | Indirection (dereference) |- | style=\"border-bottom-style: none; border-top-style: none\" | `&` | style=\"border-bottom-style: none; border-top-style: none\" | Address-of |- | style=\"border-bottom-style: none; border-top-style: none\" | `sizeof` | style=\"border-bottom-style: none; border-top-style: none\" | Sizeof |- | style=\"border-bottom-style: none; border-top-style: none\" | `_Alignof` | style=\"border-bottom-style: none; border-top-style: none\" | Alignment requirement (since C11) |- | style=\"border-bottom-style: none; border-top- style: none\" | `new`, `new[]` | style=\"border-bottom-style: none; border-top- style: none\" | Dynamic memory allocation (C++ only) |- | style=\"border-top- style: none\" | `delete`, `delete[]` | style=\"border-top-style: none\" | Dynamic memory deallocation (C++ only) |- ! rowspan=2| 4 | style=\"border-bottom-style: none\" | `.*` | style=\"border-bottom-style: none\" | Pointer to member (C++ only) | style=\"vertical-align: top\" rowspan=\"2\" | Left-to-right |- | style=\"border-bottom-style: none; border-top-style: none\" | `->*` | style=\"border-bottom-style: none; border-top-style: none\" | Pointer to member (C++ only) |- ! rowspan=3| 5 | style=\"border-bottom-style: none\" | `*` | style=\"border-bottom-style: none\" | Multiplication | style=\"vertical-align: top\" rowspan=\"3\" | Left-to-right |- | style=\"border-bottom-style: none; border-top-style: none\" | `/` | style=\"border-bottom-style: none; border-top- style: none\" | Division |- | style=\"border-bottom-style: none; border-top- style: none\" | `%` | style=\"border-bottom-style: none; border-top-style: none\" | Modulo (remainder) |- ! rowspan=2| 6 | style=\"border-bottom-style: none\" | `+` | style=\"border-bottom-style: none\" | Addition | style=\"vertical-align: top\" rowspan=\"2\" | Left-to-right |- | style=\"border-bottom-style: none; border-top-style: none\" | `-` | style=\"border-bottom-style: none; border-top- style: none\" | Subtraction |- ! rowspan=2| 7 | style=\"border-bottom-style: none\" | `<<` | style=\"border-bottom-style: none\" | Bitwise left shift | style=\"vertical-align: top\" rowspan=\"2\" | Left-to-right |- | style=\"border- bottom-style: none; border-top-style: none\" | `>>` | style=\"border-bottom- style: none; border-top-style: none\" | Bitwise right shift |- ! rowspan=1| 8 | style=\"border-bottom-style:none;\" | `<=>` | style=\"border-bottom-style:none;\" | Three-way comparison (Introduced in C++20 - C++ only) | style=\"vertical- align: top\" rowspan=\"1\" | Left-to-right |- ! rowspan=4| 9 | style=\"border- bottom-style: none\" | `<` | style=\"border-bottom-style: none\" | Less than | style=\"vertical-align: top\" rowspan=\"4\" | Left-to-right |- | style=\"border- bottom-style: none; border-top-style: none\" | `<=` | style=\"border-bottom- style: none; border-top-style: none\" | Less than or equal to |- | style=\"border-bottom-style: none; border-top-style: none\" | `>` | style=\"border-bottom-style: none; border-top-style: none\" | Greater than |- | style=\"border-bottom-style: none; border-top-style: none\" | `>=` | style=\"border-bottom-style: none; border-top-style: none\" | Greater than or equal to |- ! rowspan=2| 10 | style=\"border-bottom-style: none\" | `==` | style=\"border-bottom-style: none\" | Equal to | style=\"vertical-align: top\" rowspan=\"2\" | Left-to-right |- | style=\"border-bottom-style: none; border-top- style: none\" | `!=` | style=\"border-bottom-style: none; border-top-style: none\" | Not equal to |- ! 11 | `&` | Bitwise AND | Left-to-right |- ! 12 | `^` | Bitwise XOR (exclusive or) | Left-to-right |- ! 13 | `|` | Bitwise OR (inclusive or) | Left-to-right |- ! 14 | `&&` | Logical AND | Left-to-right |- ! 15 | `||` | Logical OR | Left-to-right |- ! rowspan=\"13\" | 16 | style=\"border-bottom-style: none\" | `?:` | style=\"border-bottom-style: none\" | Ternary conditional (see ?:) | rowspan=\"13\" | Right-to-left |- | style=\"border-bottom-style: none; border-top-style: none\" | `=` | style=\"border-bottom-style: none; border-top-style: none\" | Direct assignment |- | style=\"border-bottom-style: none; border-top-style: none\" | `+=` | style=\"border-bottom-style: none; border-top-style: none\" | Assignment by sum |- | style=\"border-bottom-style: none; border-top-style: none\" | `-=` | style=\"border-bottom-style: none; border-top-style: none\" | Assignment by difference |- | style=\"border-bottom-style: none; border-top-style: none\" | `*=` | style=\"border-bottom-style: none; border-top-style: none\" | Assignment by product |- | style=\"border-bottom-style: none; border-top-style: none\" | `/=` | style=\"border-bottom-style: none; border-top-style: none\" | Assignment by quotient |- | style=\"border-bottom-style: none; border-top-style: none\" | `%=` | style=\"border-bottom-style: none; border-top-style: none\" | Assignment by remainder |- | style=\"border-bottom-style: none; border-top-style: none\" | `<<=` | style=\"border-bottom-style: none; border-top-style: none\" | Assignment by bitwise left shift |- | style=\"border-bottom-style: none; border-top-style: none\" | `>>=` | style=\"border-bottom-style: none; border-top-style: none\" | Assignment by bitwise right shift |- | style=\"border-bottom-style: none; border-top-style: none\" | `&=` | style=\"border-bottom-style: none; border-top- style: none\" | Assignment by bitwise AND |- | style=\"border-bottom-style: none; border-top-style: none\" | `^=` | style=\"border-bottom-style: none; border-top-style: none\" | Assignment by bitwise XOR |- | style=\"border-bottom- style: none; border-top-style: none\" | `|=` | style=\"border-bottom-style: none; border-top-style: none\" | Assignment by bitwise OR |- | style=\"border- top-style: none\" | `throw` | style=\"border-top-style: none\" | Throw operator (exceptions throwing, C++ only) |- ! 17 lowest | `,` | Comma | Left-to-right |} ===Notes=== The precedence table determines the order of binding in chained expressions, when it is not expressly specified by parentheses. * For example, `++x*3` is ambiguous without some precedence rule(s). The precedence table tells us that: is 'bound' more tightly to than to , so that whatever does (now or later—see below), it does it ONLY to (and not to `x*3`); it is equivalent to (`++x`, `x*3`). * Similarly, with `3*x++`, where though the post-fix is designed to act AFTER the entire expression is evaluated, the precedence table makes it clear that ONLY gets incremented (and NOT `3*x`). In fact, the expression (`tmp=x++`, `3*tmp`) is evaluated with being a temporary value. It is functionally equivalent to something like (`tmp=3*x`, `++x`, `tmp`). center|thumb|Precedence and bindings * Abstracting the issue of precedence or binding, consider the diagram above for the expression 3+2*y[i]++. The compiler's job is to resolve the diagram into an expression, one in which several unary operators (call them 3+( . ), 2*( . ), ( . )++ and ( . )[ i ]) are competing to bind to y. The order of precedence table resolves the final sub-expression they each act upon: ( . )[ i ] acts only on y, ( . )++ acts only on y[i], 2*( . ) acts only on y[i]++ and 3+( . ) acts 'only' on 2*((y[i])++). It is important to note that WHAT sub-expression gets acted on by each operator is clear from the precedence table but WHEN each operator acts is not resolved by the precedence table; in this example, the ( . )++ operator acts only on y[i] by the precedence rules but binding levels alone do not indicate the timing of the postfix ++ (the ( . )++ operator acts only after y[i] is evaluated in the expression). Many of the operators containing multi-character sequences are given \"names\" built from the operator name of each character. For example, `+=` and `-=` are often called plus equal(s) and minus equal(s), instead of the more verbose \"assignment by addition\" and \"assignment by subtraction\". The binding of operators in C and C++ is specified (in the corresponding Standards) by a factored language grammar, rather than a precedence table. This creates some subtle conflicts. For example, in C, the syntax for a conditional expression is: logical-OR- expression ? expression : conditional-expression while in C++ it is: logical- OR-expression ? expression : assignment-expression Hence, the expression: e = a < d ? a++ : a = d is parsed differently in the two languages. In C, this expression is a syntax error, because the syntax for an assignment expression in C is: unary-expression '=' assignment-expression In C++, it is parsed as: e = (a < d ? a++ : (a = d)) which is a valid expression. If you want to use comma-as-operator within a single function argument, variable assignment, or other comma-separated list, you need to use parentheses, e.g.: int a = 1, b = 2, weirdVariable = (++a, b), d = 4; ===Criticism of bitwise and equality operators precedence=== The precedence of the bitwise logical operators has been criticized.. Conceptually, & and | are arithmetic operators like * and +. The expression is syntactically parsed as whereas the expression is parsed as . This requires parentheses to be used more often than they otherwise would. Historically, there was no syntactic distinction between the bitwise and logical operators. In BCPL, B and early C, the operators didn't exist. Instead had different meaning depending on whether they are used in a 'truth-value context' (i.e. when a Boolean value was expected, for example in it behaved as a logical operator, but in it behaved as a bitwise one). It was retained so as to keep backward compatibility with existing installations. Moreover, in C++ (and later versions of C) equality operations, with the exception of the three-way comparison operator, yield bool type values which are conceptually a single bit (1 or 0) and as such do not properly belong in \"bitwise\" operations. === C++ operator synonyms === C++ defines certain keywords to act as aliases for a number of operators: {| class=\"wikitable\" style=\"width:30%; text-align:center;\" ! Keyword || Operator |- | || `&&` |- | || `&=` |- | || `&` |- | || `|` |- | || `~` |- | || `!` |- | || `!=` |- | || `||` |- | || `|=` |- | || `^` |- | || `^=` |} These can be used exactly the same way as the punctuation symbols they replace, as they are not the same operator under a different name, but rather simple token replacements for the name (character string) of the respective operator. This means that the expressions and have identical meanings. It also means that, for example, the `bitand` keyword may be used to replace not only the bitwise-and operator but also the address-of operator, and it can even be used to specify reference types (e.g., ). The ISO C specification makes allowance for these keywords as preprocessor macros in the header file . For compatibility with C, C++ provides the header , the inclusion of which has no effect. ==See also== *Bitwise operations in C *Bit manipulation *Logical operator *Boolean algebra (logic) *Table of logic symbols *Digraphs and trigraphs in C and in C++ == References == ==External links== * . *C Operator Precedence * . Category:C (programming language) Category:C++ Category:Articles with example C++ code Category:Operators (programming) Category:Comparison of individual programming languages",
 "title": "Operators in C and C++"
}