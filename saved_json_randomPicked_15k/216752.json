{
 "id": "216752",
 "text": "Processor affinity, or CPU pinning or \"cache affinity\", enables the binding and unbinding of a process or a thread to a central processing unit (CPU) or a range of CPUs, so that the process or thread will execute only on the designated CPU or CPUs rather than any CPU. This can be viewed as a modification of the native central queue scheduling algorithm in a symmetric multiprocessing operating system. Each item in the queue has a tag indicating its kin processor. At the time of resource allocation, each task is allocated to its kin processor in preference to others. Processor affinity takes advantage of the fact that remnants of a process that was run on a given processor may remain in that processor's state (for example, data in the cache memory) after another process was run on that processor. Scheduling a CPU- intensive process that has few interrupts to execute on the same processor may improve its performance by reducing degrading events such as cache misses, but may slow down ordinary programs because they would need to wait for that CPU to become available again. A practical example of processor affinity is executing multiple instances of a non-threaded application, such as some graphics-rendering software. Scheduling-algorithm implementations vary in adherence to processor affinity. Under certain circumstances, some implementations will allow a task to change to another processor if it results in higher efficiency. For example, when two processor-intensive tasks (A and B) have affinity to one processor while another processor remains unused, many schedulers will shift task B to the second processor in order to maximize processor use. Task B will then acquire affinity with the second processor, while task A will continue to have affinity with the original processor. ==Usage== Processor affinity can effectively reduce cache problems, but it does not reduce the persistent load-balancing problem.\"White Paper - Processor Affinity\" - From tmurgent.com. Accessed 2007-07-06. Also note that processor affinity becomes more complicated in systems with non-uniform architectures. For example, a system with two dual-core hyper-threaded CPUs presents a challenge to a scheduling algorithm. There is complete affinity between two virtual CPUs implemented on the same core via hyper-threading, partial affinity between two cores on the same physical processor (as the cores share some, but not all, cache), and no affinity between separate physical processors. As other resources are also shared, processor affinity alone cannot be used as the basis for CPU dispatching. If a process has recently run on one virtual hyper-threaded CPU in a given core, and that virtual CPU is currently busy but its partner CPU is not, cache affinity would suggest that the process should be dispatched to the idle partner CPU. However, the two virtual CPUs compete for essentially all computing, cache, and memory resources. In this situation, it would typically be more efficient to dispatch the process to a different core or CPU, if one is available. This could incur a penalty when process repopulates the cache, but overall performance could be higher as the process would not have to compete for resources within the CPU. ==Specific operating systems== On Linux, the CPU affinity of a process can be altered with the taskset(1) program and the sched_setaffinity(2) system call. The affinity of a thread can be altered with one of the library functions: pthread_setaffinity_np(3) or pthread_attr_setaffinity_np(3). On SGI systems, dplace binds a process to a set of CPUs.dplace.1 - From sgi.com. Accessed 2007-07-06. On DragonFly BSD 1.9 (2007) and later versions, usched_set system call can be used to control the affinity of a process. On NetBSD 5.0, FreeBSD 7.2, DragonFly BSD 4.7 and later versions can use pthread_setaffinity_np and pthread_getaffinity_np.`` â€“ NetBSD, FreeBSD and DragonFly BSD Library Functions Manual In NetBSD, the psrset utility to set a thread's affinity to a certain CPU set. In FreeBSD, cpuset utility is used to create CPU sets and to assign processes to these sets. In DragonFly BSD 3.1 (2012) and later, usched utility can be used for assigning processes to a certain CPU set. On Windows NT and its successors, thread and process CPU affinities can be set separately by using SetThreadAffinityMaskSetThreadAffinityMask - MSDN Library and SetProcessAffinityMaskSetProcessAffinityMask - MSDN Library API calls or via the Task Manager interface (for process affinity only). macOS exposes an affinity API that provides hints to the kernel how to schedule threads according to affinity sets. On Solaris it is possible to control bindings of processes and LWPs to processor using the pbind(1)pbind(1M) - Solaris man page program. To control the affinity programmatically processor_bind(2)processor_bind(2) - Solaris man page can be used. There are more generic interfaces available such as pset_bind(2)pset_bind(2) - Oracle Solaris 11.1 Information Library - man pages section 2 or lgrp_affinity_get(3LGRP)lgrp_affinity_get(3LGRP) - Memory and Thread Placement Optimization Developer's Guide using processor set and locality groups concepts. On AIX it is possible to control bindings of processes using the bindprocessor command and the bindprocessor API. == See also == * Affinity mask == References == Category:Processor scheduling algorithms Category:Load balancing (computing)",
 "title": "Processor affinity"
}