{
 "id": "2925",
 "text": "In computability theory, the Ackermann function, named after Wilhelm Ackermann, is one of the simplest and earliest-discovered examples of a total computable function that is not primitive recursive. All primitive recursive functions are total and computable, but the Ackermann function illustrates that not all total computable functions are primitive recursive. After Ackermann's publication of his function (which had three nonnegative integer arguments), many authors modified it to suit various purposes, so that today \"the Ackermann function\" may refer to any of numerous variants of the original function. One common version, the two-argument Ackermann-Péter function is defined as follows for nonnegative integers m and n: : \\begin{array}{lcl} \\operatorname{A}(0, n) & = & n + 1 \\\\\\ \\operatorname{A}(m+1, 0) & = & \\operatorname{A}(m, 1) \\\\\\ \\operatorname{A}(m+1, n+1) & = & \\operatorname{A}(m, \\operatorname{A}(m+1, n)) \\end{array} Its value grows rapidly, even for small inputs. For example, is an integer of 19,729 decimal digits (equivalent to 265536−3, or 22222−3). ==History== In the late 1920s, the mathematicians Gabriel Sudan and Wilhelm Ackermann, students of David Hilbert, were studying the foundations of computation. Both Sudan and Ackermann are credited with discovering total computable functions (termed simply \"recursive\" in some references) that are not primitive recursive. Sudan published the lesser-known Sudan function, then shortly afterwards and independently, in 1928, Ackermann published his function \\varphi (the Greek letter phi). Ackermann's three-argument function, \\varphi(m, n, p), is defined such that for p=0,1,2, it reproduces the basic operations of addition, multiplication, and exponentiation as :\\begin{align} \\varphi(m, n, 0) &= m+n \\\\\\ \\varphi(m, n, 1) &= m\\times n \\\\\\ \\varphi(m, n, 2) &= m^n \\end{align} and for p > 2 it extends these basic operations in a way that can be compared to the hyperoperations: :\\begin{align} \\varphi(m, n, 3) &= m[4](n+1) \\\\\\ \\varphi(m, n, p) &\\gtrapprox m[p+1](n+1) && \\text{for } p > 3 \\end{align} (Aside from its historic role as a total-computable-but-not-primitive- recursive function, Ackermann's original function is seen to extend the basic arithmetic operations beyond exponentiation, although not as seamlessly as do variants of Ackermann's function that are specifically designed for that purpose—such as Goodstein's hyperoperation sequence.) In On the Infinite, David Hilbert hypothesized that the Ackermann function was not primitive recursive, but it was Ackermann, Hilbert's personal secretary and former student, who actually proved the hypothesis in his paper On Hilbert's Construction of the Real Numbers. Rózsa Péter and Raphael Robinson later developed a two-variable version of the Ackermann function that became preferred by almost all authors. The generalized hyperoperation sequence, e.g. G(m, a, b) = a[m]b, is a version of Ackermann function as well. In 1963 R.C. Buck based an intuitive two-variable with parameter order reversed variant \\operatorname{F} on the hyperoperation sequence: :\\operatorname{F}(m,n) = 2[m]n. Compared to most other versions Buck's function has no unessential offsets: :\\begin{align} \\operatorname{F}(0,n) &= 2[0]n = n + 1 \\\\\\ \\operatorname{F}(1,n) &= 2[1]n = 2 + n \\\\\\ \\operatorname{F}(2,n) &= 2[2]n = 2 \\times n \\\\\\ \\operatorname{F}(3,n) &= 2[3]n = 2^n \\\\\\ \\operatorname{F}(4,n) &= 2[4]n = 2^{2^{2^{{}^{.^{.^{{}_.2}}}}}} \\\\\\ &\\quad\\vdots \\end{align} Many other versions of Ackermann function have been investigated. ==Definition== === Definition: as m-ary function === Ackermann's original three-argument function \\varphi(m, n, p) is defined recursively as follows for nonnegative integers m,n, and p: :\\begin{align} \\varphi(m, n, 0) &= m + n \\\\\\ \\varphi(m, 0, 1) &= 0 \\\\\\ \\varphi(m, 0, 2) &= 1 \\\\\\ \\varphi(m, 0, p) &= m && \\text{for } p > 2 \\\\\\ \\varphi(m, n, p) &= \\varphi(m, \\varphi(m, n-1, p), p - 1) && \\text{for } n, p > 0 \\end{align} Of the various two-argument versions, the one developed by Péter and Robinson (called \"the\" Ackermann function by most authors) is defined for nonnegative integers m and n as follows: : \\begin{array}{lcl} \\operatorname{A}(0, n) & = & n + 1 \\\\\\ \\operatorname{A}(m+1, 0) & = & \\operatorname{A}(m, 1) \\\\\\ \\operatorname{A}(m+1, n+1) & = & \\operatorname{A}(m, A(m+1, n)) \\end{array} The Ackermann function has also been expressed in relation to the hyperoperation sequence: :A(m,n) = \\begin{cases} n+1 & m=0 \\\\\\ 2[m](n+3)-3 & m>0 \\\\\\ \\end{cases} :or, written in Knuth's up-arrow notation (extended to integer indices \\geq -2): ::: = \\begin{cases} n+1 & m=0 \\\\\\ 2\\uparrow^{m-2} (n+3) - 3 & m>0 \\\\\\ \\end{cases} :or, equivalently, in terms of Buck's function F: ::: = \\begin{cases} n+1 & m=0 \\\\\\ F(m,n+3) - 3 & m>0 \\\\\\ \\end{cases} === Definition: as iterated 1-ary function === Define f^{n} as the n-th iterate of f: :\\begin{array}{rll} f^{0}(x) & = & x \\\\\\ f^{n+1}(x) & = & f(f^{n}(x)) \\end{array} Iteration is the process of composing a function with itself a certain number of times. Function composition is an associative operation, so f(f^{n}(x)) = f^{n}(f(x)). Conceiving the Ackermann function as a sequence of unary functions, one can set \\operatorname{A}_{m}(n) = \\operatorname{A}(m,n). The function then becomes a sequence \\operatorname{A}_0, \\operatorname{A}_1, \\operatorname{A}_2, ... of unary'curried' functions, defined from iteration: : \\begin{array}{lcl} \\operatorname{A}_{0}(n) & = & n+1 \\\\\\ \\operatorname{A}_{m+1}(n) & = & \\operatorname{A}_{m}^{n+1}(1) \\\\\\ \\end{array} ==Computation== The recursive definition of the Ackermann function can naturally be transposed to a term rewriting system (TRS). ===TRS, based on 2-ary function=== The definition of the _2-ary_ Ackermann function leads to the obvious reduction rules : \\begin{array}{lll} \\text{(r1)} & A(0,n) & \\rightarrow & S(n) \\\\\\ \\text{(r2)} & A(S(m),0) & \\rightarrow & A(m,S(0)) \\\\\\ \\text{(r3)} & A(S(m),S(n)) & \\rightarrow & A(m,A(S(m),n)) \\end{array} Example Compute A(1,2) \\rightarrow_{*} 4 The reduction sequence is In each step the underlined redex is rewritten. {| |align=\"left\"|Leftmost-outermost (one-step) strategy: |align=\"left\"|Leftmost-innermost (one-step) strategy: |- |\\underline |\\underline |- |\\rightarrow_{r3} \\underline) |\\rightarrow_{r3} A(0,\\underline) |- |\\rightarrow_{r1} S(\\underline) |\\rightarrow_{r3} A(0,A(0,\\underline)) |- |\\rightarrow_{r3} S(\\underline) |\\rightarrow_{r2} A(0,A(0,\\underline)) |- |\\rightarrow_{r1} S(S(\\underline)) |\\rightarrow_{r1} A(0,\\underline) |- |\\rightarrow_{r2} S(S(\\underline)) |\\rightarrow_{r1} \\underline |- |\\rightarrow_{r1} S(S(S(S(0)))) |\\rightarrow_{r1} S(S(S(S(0)))) |- |} To compute \\operatorname{A}(m, n) one can use a stack, which initially contains the elements \\langle m,n \\rangle. Then repeatedly the two top elements are replaced according to the ruleshere: leftmost-innermost strategy! : \\begin{array}{lllllllll} \\text{(r1)} & 0 &,& n & \\rightarrow & (n+1) \\\\\\ \\text{(r2)} & (m+1) &,& 0 & \\rightarrow & m &,& 1 \\\\\\ \\text{(r3)} & (m+1) &,& (n+1) & \\rightarrow & m &,& (m+1) &,& n \\end{array} Schematically, starting from \\langle m,n \\rangle: WHILE stackLength <> 1 { POP 2 elements; PUSH 1 or 2 or 3 elements, applying the rules r1, r2, r3 } The pseudocode is published in . For example, on input \\langle 2,1 \\rangle, {| |align=\"left\"|the stack configurations |align=\"left\"|reflect the reductionFor better readability S(0) is notated as 1, S(S(0)) is notated as 2, S(S(S(0))) is notated as 3, etc... |- |\\underline{2,1} |\\underline{A(2,1)} |- |\\rightarrow 1,\\underline{2,0} |\\rightarrow_{r1} A(1,\\underline{A(0,2)}) |- |\\rightarrow 1,\\underline{1,1} |\\rightarrow_{r2} A(1,\\underline{A(1,1)}) |- |\\rightarrow 1,0,\\underline{1,0} |\\rightarrow_{r3} A(1,A(0,\\underline{A(1,0)})) |- |\\rightarrow 1,0,\\underline{0,1} |\\rightarrow_{r2} A(1,A(0,\\underline{A(0,1)})) |- |\\rightarrow 1,\\underline{0,2} |\\rightarrow_{r1} A(1,\\underline{A(0,2)}) |- |\\rightarrow \\underline{1,3} |\\rightarrow_{r1} \\underline{A(1,3)} |- |\\rightarrow 0,\\underline{1,2} |\\rightarrow_{r3} A(0,\\underline{A(1,2)}) |- |\\rightarrow 0,0,\\underline{1,1} |\\rightarrow_{r3} A(0,A(0,\\underline{A(1,1)})) |- |\\rightarrow 0,0,0,\\underline{1,0} |\\rightarrow_{r3} A(0,A(0,A(0,\\underline{A(1,0)}))) |- |\\rightarrow 0,0,0,\\underline{0,1} |\\rightarrow_{r2} A(0,A(0,A(0,\\underline{A(0,1)}))) |- |\\rightarrow 0,0,\\underline{0,2} |\\rightarrow_{r1} A(0,A(0,\\underline{A(0,2)})) |- |\\rightarrow 0,\\underline{0,3} |\\rightarrow_{r1} A(0,\\underline{A(0,3)}) |- |\\rightarrow \\underline{0,4} |\\rightarrow_{r1} \\underline{A(0,4)} |- |\\rightarrow 5 |\\rightarrow_{r1} 5 |} Remarks *The leftmost-innermost strategy is implemented in 225 computer languages on Rosetta Code. *For all m,n the computation of A(m,n) takes no more than (A(m,n) + 1)^m steps. * pointed out that in the computation of \\operatorname{A}(m,n) the maximum length of the stack is \\operatorname{A}(m,n), as long as m>0. :Their own algorithm, inherently iterative, computes \\operatorname{A}(m,n) within \\mathcal{O}(m \\operatorname{A}(m,n)) time and within \\mathcal{O}(m) space. ===TRS, based on iterated 1-ary function=== The definition of the iterated _1-ary_ Ackermann functions leads to different reduction rules : \\begin{array}{lll} \\text{(r4)} & A(S(0),0,n) & \\rightarrow & S(n) \\\\\\ \\text{(r5)} & A(S(0),S(m),n) & \\rightarrow & A(S(n),m,S(0)) \\\\\\ \\text{(r6)} & A(S(S(x)),m,n) & \\rightarrow & A(S(0),m,A(S(x),m,n)) \\end{array} As function composition is associative, instead of rule r6 one can define : \\begin{array}{lll} \\text{(r7)} & A(S(S(x)),m,n) & \\rightarrow & A(S(x),m,A(S(0),m,n)) \\end{array} Like in the previous section the computation of \\operatorname{A}^1_m(n) can be implemented with a stack. Initially the stack contains the three elements \\langle 1,m,n \\rangle. Then repeatedly the three top elements are replaced according to the rules : \\begin{array}{lllllllll} \\text{(r4)} & 1 &, 0 &, n & \\rightarrow & (n+1) \\\\\\ \\text{(r5)} & 1 &, (m+1) &, n & \\rightarrow & (n+1) &, m &, 1 \\\\\\ \\text{(r6)} & (x+2) &, m &, n & \\rightarrow & 1 &, m &, (x+1) &, m &, n \\\\\\ \\end{array} Schematically, starting from \\langle 1, m,n \\rangle: WHILE stackLength <> 1 { POP 3 elements; PUSH 1 or 3 or 5 elements, applying the rules r4, r5, r6; } Example On input \\langle 1,2,1 \\rangle the successive stack configurations are :\\begin{align} & \\underline{1,2,1} \\rightarrow_{r5} \\underline{2,1,1} \\rightarrow_{r6} 1,1,\\underline{1,1,1} \\rightarrow_{r5} 1,1,\\underline{2,0,1} \\rightarrow_{r6} 1,1,1,0,\\underline{1,0,1} \\\\\\ & \\rightarrow_{r4} 1,1,\\underline{1,0,2} \\rightarrow_{r4} \\underline{1,1,3} \\rightarrow_{r5} \\underline{4,0,1} \\rightarrow_{r6} 1,0,\\underline{3,0,1} \\rightarrow_{r6} 1,0,1,0,\\underline{2,0,1} \\\\\\ & \\rightarrow_{r6} 1,0,1,0,1,0,\\underline{1,0,1} \\rightarrow_{r4} 1,0,1,0,\\underline{1,0,2} \\rightarrow_{r4} 1,0,\\underline{1,0,3} \\rightarrow_{r4} \\underline{1,0,4} \\rightarrow_{r4} 5 \\end{align} The corresponding equalities are :\\begin{align} & A_2(1) = A^2_1(1) = A_1(A_1(1)) = A_1(A^2_0(1)) = A_1(A_0(A_0(1))) \\\\\\ & = A_1(A_0(2)) = A_1(3) = A^4_0(1) = A_0(A^3_0(1)) = A_0(A_0(A^2_0(1))) \\\\\\ & = A_0(A_0(A_0(A_0(1)))) = A_0(A_0(A_0(2))) = A_0(A_0(3)) = A_0(4) = 5 \\end{align} When reduction rule r7 is used instead of rule r6, the replacements in the stack will follow :\\begin{array}{lllllllll} \\text{(r7)} & (x+2) &, m &, n & \\rightarrow & (x+1) &, m &, 1 &, m &, n \\end{array} The successive stack configurations will then be :\\begin{align} & \\underline{1,2,1} \\rightarrow_{r5} \\underline{2,1,1} \\rightarrow_{r7} 1,1,\\underline{1,1,1} \\rightarrow_{r5} 1,1,\\underline{2,0,1} \\rightarrow_{r7} 1,1,1,0,\\underline{1,0,1} \\\\\\ & \\rightarrow_{r4} 1,1,\\underline{1,0,2} \\rightarrow_{r4} \\underline{1,1,3} \\rightarrow_{r5} \\underline{4,0,1} \\rightarrow_{r7} 3,0,\\underline{1,0,1} \\rightarrow_{r4} \\underline{3,0,2} \\\\\\ & \\rightarrow_{r7} 2,0,\\underline{1,0,2} \\rightarrow_{r4} \\underline{2,0,3} \\rightarrow_{r7} 1,0,\\underline{1,0,3} \\rightarrow_{r4} \\underline{1,0,4} \\rightarrow_{r4} 5 \\end{align} The corresponding equalities are :\\begin{align} & A_2(1) = A^2_1(1) = A_1(A_1(1)) = A_1(A^2_0(1)) = A_1(A_0(A_0(1))) \\\\\\ & = A_1(A_0(2)) = A_1(3) = A^4_0(1) = A^3_0(A_0(1)) = A^3_0(2) \\\\\\ & = A^2_0(A_0(2)) = A^2_0(3) = A_0(A_0(3)) = A_0(4) = 5 \\end{align} Remarks *On any given input the TRSs presented so far converge in the same number of steps. They also use the same reduction rules (in this comparison the rules r1, r2, r3 are considered \"the same as\" the rules r4, r5, r6/r7 respectively). For example, the reduction of A(2,1) converges in 14 steps: 6 × r1, 3 × r2, 5 × r3. The reduction of A_2(1) converges in the same 14 steps: 6 × r4, 3 × r5, 5 × r6/r7. The TRSs differ in the order in which the reduction rules are applied. *When A_{i}(n) is computed following the rules {r4, r5, r6}, the maximum length of the stack stays below 2 \\times A(i,n). When reduction rule r7 is used instead of rule r6, the maximum length of the stack is only 2(i+2). The length of the stack reflects the recursion depth. As the reduction according to the rules {r4, r5, r7} involves a smaller maximum depth of recursion,The maximum depth of recursion refers to the number of levels of activation of a procedure which exist during the deepest call of the procedure. this computation is more efficient in that respect. ===TRS, based on hyperoperators=== As -- or -- showed explicitly, the Ackermann function can be expressed in terms of the hyperoperation sequence: :A(m,n) = \\begin{cases} n+1 & m=0 \\\\\\ 2[m](n+3) - 3 & m>0 \\\\\\ \\end{cases} or, after removal of the constant 2 from the parameter list, in terms of Buck's function ::: = \\begin{cases} n+1 & m=0 \\\\\\ F(m,n+3) - 3 & m>0 \\\\\\ \\end{cases} Buck's function \\operatorname{F}(m,n) = 2[m]n, a variant of Ackermann function by itself, can be computed with the following reduction rules: : \\begin{array}{lll} \\text{(b1)} & F(S(0),0,n) & \\rightarrow & S(n) \\\\\\ \\text{(b2)} & F(S(0),S(0),0) & \\rightarrow & S(S(0)) \\\\\\ \\text{(b3)} & F(S(0),S(S(0)),0) & \\rightarrow & 0 \\\\\\ \\text{(b4)} & F(S(0),S(S(S(m))),0) & \\rightarrow & S(0) \\\\\\ \\text{(b5)} & F(S(0),S(m),S(n)) & \\rightarrow & F(S(n),m,F(S(0),S(m),0)) \\\\\\ \\text{(b6)} & F(S(S(x)),m,n) & \\rightarrow & F(S(0),m,F(S(x),m,n)) \\end{array} Instead of rule b6 one can define the rule : \\begin{array}{lll} \\text{(b7)} & F(S(S(x)),m,n) & \\rightarrow & F(S(x),m,F(S(0),m,n)) \\end{array} To compute the Ackermann function it suffices to add three reduction rules : \\begin{array}{lll} \\text{(r8)} & A(0,n) & \\rightarrow & S(n) \\\\\\ \\text{(r9)} & A(S(m),n) & \\rightarrow & P(F(S(0),S(m),S(S(S(n))))) \\\\\\ \\text{(r10)} & P(S(S(S(m)))) & \\rightarrow & m \\\\\\ \\end{array} These rules take care of the base case A(0,n), the alignment (n+3) and the fudge (-3). Example Compute A(2,1) \\rightarrow_{*} 5 {| |align=\"left\"|using reduction rule \\text{b7}: |align=\"left\"|using reduction rule \\text{b6}: |- |\\underline{A(2,1)} |\\underline{A(2,1)} |- |\\rightarrow_{r9} P(\\underline{F(1,2,4)}) |\\rightarrow_{r9} P(\\underline{F(1,2,4)}) |- |\\rightarrow_{b5} P(F(4,1,\\underline{F(1,2,0)})) |\\rightarrow_{b5} P(F(4,1,\\underline{F(1,2,0)})) |- |\\rightarrow_{b3} P(\\underline{F(4,1,0)}) |\\rightarrow_{b3} P(\\underline{F(4,1,0)}) |- |\\rightarrow_{b7} P(F(3,1,\\underline{F(1,1,0)})) |\\rightarrow_{b6} P(F(1,1,\\underline{F(3,1,0)})) |- |\\rightarrow_{b2} P(\\underline{F(3,1,2)}) |\\rightarrow_{b6} P(F(1,1,F(1,1,\\underline{F(2,1,0)}))) |- |\\rightarrow_{b7} P(F(2,1,\\underline{F(1,1,2)})) |\\rightarrow_{b6} P(F(1,1,F(1,1,F(1,1,\\underline{F(1,1,0)})))) |- |\\rightarrow_{b5} P(F(2,1,F(2,0,\\underline{F(1,1,0)}))) |\\rightarrow_{b2} P(F(1,1,F(1,1,\\underline{F(1,1,2)}))) |- |\\rightarrow_{b2} P(F(2,1,\\underline{F(2,0,2)})) |\\rightarrow_{b5} P(F(1,1,F(1,1,F(2,0,\\underline{F(1,1,0)})))) |- |\\rightarrow_{b7} P(F(2,1,F(1,0,\\underline{F(1,0,2)}))) |\\rightarrow_{b2} P(F(1,1,F(1,1,\\underline{F(2,0,2)}))) |- |\\rightarrow_{b1} P(F(2,1,\\underline{F(1,0,3)})) |\\rightarrow_{b6} P(F(1,1,F(1,1,F(1,0,\\underline{F(1,0,2)})))) |- |\\rightarrow_{b1} P(\\underline{F(2,1,4)}) |\\rightarrow_{b1} P(F(1,1,F(1,1,\\underline{F(1,0,3)}))) |- |\\rightarrow_{b7} P(F(1,1,\\underline{F(1,1,4)})) |\\rightarrow_{b1} P(F(1,1,\\underline{F(1,1,4)})) |- |\\rightarrow_{b5} P(F(1,1,F(4,0,\\underline{F(1,1,0)}))) |\\rightarrow_{b5} P(F(1,1,F(4,0,\\underline{F(1,1,0)}))) |- |\\rightarrow_{b2} P(F(1,1,\\underline{F(4,0,2)})) |\\rightarrow_{b2} P(F(1,1,\\underline{F(4,0,2)})) |- |\\rightarrow_{b7} P(F(1,1,F(3,0,\\underline{F(1,0,2)}))) |\\rightarrow_{b6} P(F(1,1,F(1,0,\\underline{F(3,0,2)}))) |- |\\rightarrow_{b1} P(F(1,1,\\underline{F(3,0,3)})) |\\rightarrow_{b6} P(F(1,1,F(1,0,F(1,0,\\underline{F(2,0,2)})))) |- |\\rightarrow_{b7} P(F(1,1,F(2,0,\\underline{F(1,0,3)}))) |\\rightarrow_{b6} P(F(1,1,F(1,0,F(1,0,F(1,0,\\underline{F(1,0,2)}))))) |- |\\rightarrow_{b1} P(F(1,1,\\underline{F(2,0,4)})) |\\rightarrow_{b1} P(F(1,1,F(1,0,F(1,0,\\underline{F(1,0,3)})))) |- |\\rightarrow_{b7} P(F(1,1,F(1,0,\\underline{F(1,0,4)}))) |\\rightarrow_{b1} P(F(1,1,F(1,0,\\underline{F(1,0,4)}))) |- |\\rightarrow_{b1} P(F(1,1,\\underline{F(1,0,5)})) |\\rightarrow_{b1} P(F(1,1,\\underline{F(1,0,5)})) |- |\\rightarrow_{b1} P(\\underline{F(1,1,6)}) |\\rightarrow_{b1} P(\\underline{F(1,1,6)}) |- |\\rightarrow_{b5} P(F(6,0,\\underline{F(1,1,0)})) |\\rightarrow_{b5} P(F(6,0,\\underline{F(1,1,0)})) |- |\\rightarrow_{b2} P(\\underline{F(6,0,2)}) |\\rightarrow_{b2} P(\\underline{F(6,0,2)}) |- |\\rightarrow_{b7} P(F(5,0,\\underline{F(1,0,2)})) |\\rightarrow_{b6} P(F(1,0,\\underline{F(5,0,2)})) |- |\\rightarrow_{b1} P(\\underline{F(5,0,3)}) |\\rightarrow_{b6} P(F(1,0,F(1,0,\\underline{F(4,0,2)}))) |- |\\rightarrow_{b7} P(F(4,0,\\underline{F(1,0,3)})) |\\rightarrow_{b6} P(F(1,0,F(1,0,F(1,0,\\underline{F(3,0,2)})))) |- |\\rightarrow_{b1} P(\\underline{F(4,0,4)}) |\\rightarrow_{b6} P(F(1,0,F(1,0,F(1,0,F(1,0,\\underline{F(2,0,2)}))))) |- |\\rightarrow_{b7} P(F(3,0,\\underline{F(1,0,4)})) |\\rightarrow_{b6} P(F(1,0,F(1,0,F(1,0,F(1,0,F(1,0,\\underline{F(1,0,2)})))))) |- |\\rightarrow_{b1} P(\\underline{F(3,0,5)}) |\\rightarrow_{b1} P(F(1,0,F(1,0,F(1,0,F(1,0,\\underline{F(1,0,3)}))))) |- |\\rightarrow_{b7} P(F(2,0,\\underline{F(1,0,5)})) |\\rightarrow_{b1} P(F(1,0,F(1,0,F(1,0,\\underline{F(1,0,4)})))) |- |\\rightarrow_{b1} P(\\underline{F(2,0,6)}) |\\rightarrow_{b1} P(F(1,0,F(1,0,\\underline{F(1,0,5)}))) |- |\\rightarrow_{b7} P(F(1,0,\\underline{F(1,0,6)})) |\\rightarrow_{b1} P(F(1,0,\\underline{F(1,0,6)})) |- |\\rightarrow_{b1} P(\\underline{F(1,0,7)}) |\\rightarrow_{b1} P(\\underline{F(1,0,7)}) |- |\\rightarrow_{b1} \\underline{P(8)} |\\rightarrow_{b1} \\underline{P(8)} |- |\\rightarrow_{r10} 5 |\\rightarrow_{r10} 5 |} The matching equalities are *when the TRS with the reduction rule \\text{b6} is applied: :\\begin{align} & A(2,1) +3 = F(2,4) = \\dots = F^6(0,2) = F(0,F^5(0,2)) = F(0,F(0,F^4(0,2))) \\\\\\ & = F(0,F(0,F(0,F^3(0,2)))) = F(0,F(0,F(0,F(0,F^2(0,2))))) = F(0,F(0,F(0,F(0,F(0,F(0,2)))))) \\\\\\ & = F(0,F(0,F(0,F(0,F(0,3))))) = F(0,F(0,F(0,F(0,4)))) = F(0,F(0,F(0,5))) = F(0,F(0,6)) = F(0,7) = 8 \\end{align} *when the TRS with the reduction rule \\text{b7} is applied: :\\begin{align} & A(2,1) +3 = F(2,4) = \\dots = F^6(0,2) = F^5(0,F(0,2)) = F^5(0,3) = F^4(0,F(0,3)) = F^4(0,4) \\\\\\ & = F^3(0,F(0,4)) = F^3(0,5) = F^2(0,F(0,5)) = F^2(0,6) = F(0,F(0,6)) = F(0,7) = 8 \\end{align} Remarks *The computation of \\operatorname{A}_{i}(n) according to the rules {b1 - b5, b6, r8 - r10} is deeply recursive. The maximum depth of nested Fs is A(i,n)+1. The culprit is the order in which iteration is executed: F^{n+1}(x) = F(F^{n}(x)). The first F disappears only after the whole sequence is unfolded. *The computation according to the rules {b1 - b5, b7, r8 - r10} is more efficient in that respect. The iteration F^{n+1}(x) = F^{n}(F(x)) simulates the repeated loop over a block of code.LOOP n+1 TIMES DO F The nesting is limited to (i+1), one recursion level per iterated function. showed this correspondence. *These considerations concern the recursion depth only. Either way of iterating leads to the same number of reduction steps, involving the same rules (when the rules b6 and b7 are considered \"the same\"). The reduction of A(2,1) for instance converges in 35 steps: 12 × b1, 4 × b2, 1 × b3, 4 × b5, 12 × b6/b7, 1 × r9, 1 × r10. The modus iterandi only affects the order in which the reduction rules are applied. *A real gain of execution time can only be achieved by not recalculating subresults over and over again. Memoization is an optimization technique where the results of function calls are cached and returned when the same inputs occur again. See for instance . published a cunning algorithm which computes A(i,n) within \\mathcal{O}(i A(i,n)) time and within \\mathcal{O}(i) space. ===Huge numbers=== To demonstrate how the computation of A(4, 3) results in many steps and in a large number: :\\begin{align} A(4, 3) & \\rightarrow A(3, A(4, 2)) \\\\\\ & \\rightarrow A(3, A(3, A(4, 1))) \\\\\\ & \\rightarrow A(3, A(3, A(3, A(4, 0)))) \\\\\\ & \\rightarrow A(3, A(3, A(3, A(3, 1)))) \\\\\\ & \\rightarrow A(3, A(3, A(3, A(2, A(3, 0))))) \\\\\\ & \\rightarrow A(3, A(3, A(3, A(2, A(2, 1))))) \\\\\\ & \\rightarrow A(3, A(3, A(3, A(2, A(1, A(2, 0)))))) \\\\\\ & \\rightarrow A(3, A(3, A(3, A(2, A(1, A(1, 1)))))) \\\\\\ & \\rightarrow A(3, A(3, A(3, A(2, A(1, A(0, A(1, 0))))))) \\\\\\ & \\rightarrow A(3, A(3, A(3, A(2, A(1, A(0, A(0, 1))))))) \\\\\\ & \\rightarrow A(3, A(3, A(3, A(2, A(1, A(0, 2)))))) \\\\\\ & \\rightarrow A(3, A(3, A(3, A(2, A(1, 3))))) \\\\\\ & \\rightarrow A(3, A(3, A(3, A(2, A(0, A(1, 2)))))) \\\\\\ & \\rightarrow A(3, A(3, A(3, A(2, A(0, A(0, A(1, 1))))))) \\\\\\ & \\rightarrow A(3, A(3, A(3, A(2, A(0, A(0, A(0, A(1, 0)))))))) \\\\\\ & \\rightarrow A(3, A(3, A(3, A(2, A(0, A(0, A(0, A(0, 1)))))))) \\\\\\ & \\rightarrow A(3, A(3, A(3, A(2, A(0, A(0, A(0, 2)) )) )) ) \\\\\\ & \\rightarrow A(3, A(3, A(3, A(2, A(0, A(0, 3)))))) \\\\\\ & \\rightarrow A(3, A(3, A(3, A(2, A(0, 4))))) \\\\\\ & \\rightarrow A(3, A(3, A(3, A(2, 5)))) \\\\\\ & \\qquad\\vdots \\\\\\ & \\rightarrow A(3, A(3, A(3, 13))) \\\\\\ & \\qquad\\vdots \\\\\\ & \\rightarrow A(3, A(3, 65533)) \\\\\\ &\\qquad\\vdots \\\\\\ & \\rightarrow A(3, 2^{65536} - 3) \\\\\\ &\\qquad\\vdots \\\\\\ & \\rightarrow 2^{2^{65536}} - 3. \\\\\\ \\end{align} == Table of values == Computing the Ackermann function can be restated in terms of an infinite table. First, place the natural numbers along the top row. To determine a number in the table, take the number immediately to the left. Then use that number to look up the required number in the column given by that number and one row up. If there is no number to its left, simply look at the column headed \"1\" in the previous row. Here is a small upper-left portion of the table: {| class=\"wikitable\" |+ Values of A(m, n) |- ! ! 0 ! 1 ! 2 ! 3 ! 4 ! n |- ! 0 | 1 || 2 || 3 || 4 || 5 || n + 1 |- ! 1 | 2 || 3 || 4 || 5 || 6 || n + 2 = 2 + (n + 3) - 3 |- ! 2 | 3 || 5 || 7 || 9 || 11 || 2n + 3 = 2\\cdot(n + 3) - 3 |- ! 3 | 5 || 13 || 29 || 61 || 125 || 2^{(n + 3)} - 3 |- ! 4 | 13 ={2^{2^{2}}}-3 =2\\uparrow\\uparrow 3 - 3 | 65533 ={2^{2^{2^{2}}}}-3 =2\\uparrow\\uparrow 4 - 3 | 265536 − 3 ={2^{2^{2^{2^{2}}}}}-3 =2\\uparrow\\uparrow 5 - 3 | {2^{2^{65536}}} - 3 ={2^{2^{2^{2^{2^{2}}}}}}-3 =2\\uparrow\\uparrow 6 - 3 | {2^{2^{2^{65536}}}} - 3 ={2^{2^{2^{2^{2^{2^{2}}}}}}}-3 =2\\uparrow\\uparrow 7 - 3 | \\begin{matrix}\\underbrace{{2^2}^{{\\cdot}^{{\\cdot}^{{\\cdot}^2}}}}_{n+3} - 3\\end{matrix} =2\\uparrow\\uparrow (n+3) - 3 |- ! 5 | 65533 =2\\uparrow\\uparrow(2\\uparrow\\uparrow 2) - 3 =2\\uparrow\\uparrow\\uparrow 3 - 3 | 2\\uparrow\\uparrow\\uparrow 4 - 3 | 2\\uparrow\\uparrow\\uparrow 5 - 3 | 2\\uparrow\\uparrow\\uparrow 6 - 3 | 2\\uparrow\\uparrow\\uparrow 7 - 3 | 2\\uparrow\\uparrow\\uparrow (n+3) - 3 |- ! 6 | 2\\uparrow\\uparrow\\uparrow\\uparrow 3 - 3 | 2\\uparrow\\uparrow\\uparrow\\uparrow 4 - 3 | 2\\uparrow\\uparrow\\uparrow\\uparrow 5 - 3 | 2\\uparrow\\uparrow\\uparrow\\uparrow 6 - 3 | 2\\uparrow\\uparrow\\uparrow\\uparrow 7 - 3 | 2\\uparrow\\uparrow\\uparrow\\uparrow (n+3) - 3 |- ! m | (2\\to 3\\to(m-2))-3 | (2\\to 4\\to(m-2))-3 | (2\\to 5\\to(m-2))-3 | (2\\to 6\\to(m-2))-3 | (2\\to 7\\to(m-2))-3 | (2\\to(n+3)\\to(m-2))-3 |} The numbers here which are only expressed with recursive exponentiation or Knuth arrows are very large and would take up too much space to notate in plain decimal digits. Despite the large values occurring in this early section of the table, some even larger numbers have been defined, such as Graham's number, which cannot be written with any small number of Knuth arrows. This number is constructed with a technique similar to applying the Ackermann function to itself recursively. This is a repeat of the above table, but with the values replaced by the relevant expression from the function definition to show the pattern clearly: {| class=\"wikitable\" |+ Values of A(m, n) |- ! ! 0 ! 1 ! 2 ! 3 ! 4 ! n |- ! 0 | 0+1 || 1+1 || 2+1 || 3+1 || 4+1 || n + 1 |- ! 1 | A(0, 1) || A(0, A(1, 0)) = A(0, 2) || A(0, A(1, 1)) = A(0, 3) || A(0, A(1, 2)) = A(0, 4) || A(0, A(1, 3)) = A(0, 5) || A(0, A(1, n−1)) |- ! 2 | A(1, 1) || A(1, A(2, 0)) = A(1, 3) || A(1, A(2, 1)) = A(1, 5) || A(1, A(2, 2)) = A(1, 7) || A(1, A(2, 3)) = A(1, 9) || A(1, A(2, n−1)) |- ! 3 | A(2, 1) || A(2, A(3, 0)) = A(2, 5) || A(2, A(3, 1)) = A(2, 13) || A(2, A(3, 2)) = A(2, 29) || A(2, A(3, 3)) = A(2, 61) || A(2, A(3, n−1)) |- ! 4 | A(3, 1) || A(3, A(4, 0)) = A(3, 13) || A(3, A(4, 1)) = A(3, 65533) || A(3, A(4, 2)) || A(3, A(4, 3)) || A(3, A(4, n−1)) |- ! 5 | A(4, 1) || A(4, A(5, 0)) || A(4, A(5, 1)) || A(4, A(5, 2)) || A(4, A(5, 3)) || A(4, A(5, n−1)) |- ! 6 | A(5, 1) || A(5, A(6, 0)) || A(5, A(6, 1)) || A(5, A(6, 2)) || A(5, A(6, 3)) || A(5, A(6, n−1)) |} == Properties == === General remarks === *It may not be immediately obvious that the evaluation of A(m, n) always terminates. However, the recursion is bounded because in each recursive application either m decreases, or m remains the same and n decreases. Each time that n reaches zero, m decreases, so m eventually reaches zero as well. (Expressed more technically, in each case the pair (m,n) decreases in the lexicographic order on pairs, which is a well-ordering, just like the ordering of single non-negative integers; this means one cannot go down in the ordering infinitely many times in succession.) However, when m decreases there is no upper bound on how much n can increase — and it will often increase greatly. *For small values of m like 1, 2, or 3, the Ackermann function grows relatively slowly with respect to n (at most exponentially). For m\\geq 4, however, it grows much more quickly; even A(4,2) is about 2, and the decimal expansion of is very large by any typical measure. *An interesting aspect is that the only arithmetic operation it ever uses is addition of 1. Its fast growing power is based solely on nested recursion. This also implies that its running time is at least proportional to its output, and so is also extremely huge. In actuality, for most cases the running time is far larger than the output; see above. *A single-argument version f(n)=A(n,n) that increases both m and n at the same time dwarfs every primitive recursive function, including very fast-growing functions such as the exponential function, the factorial function, multi- and superfactorial functions, and even functions defined using Knuth's up-arrow notation (except when the indexed up-arrow is used). It can be seen that f(n) is roughly comparable to f_{\\omega}(n) in the fast- growing hierarchy. This extreme growth can be exploited to show that f which is obviously computable on a machine with infinite memory such as a Turing machine and so is a computable function, grows faster than any primitive recursive function and is therefore not primitive recursive. === Not primitive recursive === The Ackermann function grows faster than any primitive recursive function and therefore is not itself primitive recursive. Specifically, one shows that to every primitive recursive function f(x_1,\\ldots,x_n) there exists a non-negative integer t such that for all non-negative integers x_1,\\ldots,x_n, :f(x_1,\\ldots,x_n) Once this is established, it follows that A itself is not primitive recursive, since otherwise putting x_1=x_2=t would lead to the contradiction A(t,t) The proof proceeds as follows: define the class \\mathcal{A} of all functions that grow slower than the Ackermann function :\\mathcal{A}=\\left\\\\{ f\\,\\bigg|\\,\\exists t\\ \\forall x_1\\cdots \\forall x_n:\\ f(x_1,\\ldots,x_n) and show that \\mathcal{A} contains all primitive recursive functions. The latter is achieved by showing that \\mathcal{A} contains the constant functions, the successor function, the projection functions and that it is closed under the operations of function composition and primitive recursion. == Inverse == Since the function considered above grows very rapidly, its inverse function, f, grows very slowly. This inverse Ackermann function f−1 is usually denoted by α. In fact, α(n) is less than 5 for any practical input size n, since is on the order of 2^{2^{2^{2^{16}}}}. This inverse appears in the time complexity of some algorithms, such as the disjoint-set data structure and Chazelle's algorithm for minimum spanning trees. Sometimes Ackermann's original function or other variations are used in these settings, but they all grow at similarly high rates. In particular, some modified functions simplify the expression by eliminating the −3 and similar terms. A two-parameter variation of the inverse Ackermann function can be defined as follows, where \\lfloor x \\rfloor is the floor function: :\\alpha(m,n) = \\min\\\\{i \\geq 1 : A(i,\\lfloor m/n \\rfloor) \\geq \\log_2 n\\\\}. This function arises in more precise analyses of the algorithms mentioned above, and gives a more refined time bound. In the disjoint-set data structure, m represents the number of operations while n represents the number of elements; in the minimum spanning tree algorithm, m represents the number of edges while n represents the number of vertices. Several slightly different definitions of exist; for example, is sometimes replaced by n, and the floor function is sometimes replaced by a ceiling. Other studies might define an inverse function of one where m is set to a constant, such that the inverse applies to a particular row. The inverse of the Ackermann function is primitive recursive. ==Use as benchmark== The Ackermann function, due to its definition in terms of extremely deep recursion, can be used as a benchmark of a compiler's ability to optimize recursion. The first published use of Ackermann's function in this way was in 1970 by Dragoș Vaida and, almost simultaneously, in 1971, by Yngve Sundblad. Sundblad's seminal paper was taken up by Brian Wichmann (co-author of the Whetstone benchmark) in a trilogy of papers written between 1975 and 1982. ==See also== * Computability theory * Double recursion * Fast-growing hierarchy * Goodstein function * Primitive recursive function * Recursion (computer science) ==Notes== ==References== ==Bibliography== * * * * * * * * * * * * * * * * * * * * * * * * * * ==External links== * * * * An animated Ackermann function calculator * Ackerman function implemented using a for loop * Scott Aaronson, Who can name the biggest number? (1999) * Ackermann functions. Includes a table of some values. * Hyper-operations: Ackermann's Function and New Arithmetical Operation * Robert Munafo's Large Numbers describes several variations on the definition of A. * Gabriel Nivasch, Inverse Ackermann without pain on the inverse Ackermann function. * Raimund Seidel, Understanding the inverse Ackermann function (PDF presentation). * The Ackermann function written in different programming languages, (on Rosetta Code) * Ackermann's Function (Archived 2009-10-24)—Some study and programming by Harry J. Smith. Category:Arithmetic Category:Large integers Category:Special functions Category:Theory of computation Category:Computability theory",
 "title": "Ackermann function"
}