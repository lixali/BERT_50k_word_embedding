{
 "id": "665285",
 "text": "The SQL SELECT statement returns a result set of records, from one or more tables. A SELECT statement retrieves zero or more rows from one or more database tables or database views. In most applications, `SELECT` is the most commonly used data manipulation language (DML) command. As SQL is a declarative programming language, `SELECT` queries specify a result set, but do not specify how to calculate it. The database translates the query into a \"query plan\" which may vary between executions, database versions and database software. This functionality is called the \"query optimizer\" as it is responsible for finding the best possible execution plan for the query, within applicable constraints. The SELECT statement has many optional clauses: * `SELECT` clause is the list of columns or SQL expressions that must be returned by the query. This is approximately the relational algebra projection operation. * `AS` optionally provides an alias for each column or expression in the `SELECT` clause. This is the relational algebra rename operation. * `FROM` specifies from which table to get the data.Omitting FROM clause isn't standard, but allowed by most major DBMSes. * `WHERE` specifies which rows to retrieve. This is approximately the relational algebra selection operation. * `GROUP BY` groups rows sharing a property so that an aggregate function can be applied to each group. * `HAVING` selects among the groups defined by the GROUP BY clause. * `ORDER BY` specifies how to order the returned rows. == Overview == `SELECT` is the most common operation in SQL, called \"the query\". `SELECT` retrieves data from one or more tables, or expressions. Standard `SELECT` statements have no persistent effects on the database. Some non- standard implementations of `SELECT` can have persistent effects, such as the `SELECT INTO` syntax provided in some databases. Queries allow the user to describe desired data, leaving the database management system (DBMS) to carry out planning, optimizing, and performing the physical operations necessary to produce that result as it chooses. A query includes a list of columns to include in the final result, normally immediately following the `SELECT` keyword. An asterisk (\"`*`\") can be used to specify that the query should return all columns of the queried tables. `SELECT` is the most complex statement in SQL, with optional keywords and clauses that include: * The `FROM` clause, which indicates the table(s) to retrieve data from. The `FROM` clause can include optional `JOIN` subclauses to specify the rules for joining tables. * The `WHERE` clause includes a comparison predicate, which restricts the rows returned by the query. The `WHERE` clause eliminates all rows from the result set where the comparison predicate does not evaluate to True. * The `GROUP BY` clause projects rows having common values into a smaller set of rows. `GROUP BY` is often used in conjunction with SQL aggregation functions or to eliminate duplicate rows from a result set. The `WHERE` clause is applied before the `GROUP BY` clause. * The `HAVING` clause includes a predicate used to filter rows resulting from the `GROUP BY` clause. Because it acts on the results of the `GROUP BY` clause, aggregation functions can be used in the `HAVING` clause predicate. * The `ORDER BY` clause identifies which column[s] to use to sort the resulting data, and in which direction to sort them (ascending or descending). Without an `ORDER BY` clause, the order of rows returned by an SQL query is undefined. * The `DISTINCT` keyword eliminates duplicate data. The following example of a `SELECT` query returns a list of expensive books. The query retrieves all rows from the Book table in which the price column contains a value greater than 100.00. The result is sorted in ascending order by title. The asterisk (*) in the select list indicates that all columns of the Book table should be included in the result set. SELECT * FROM Book WHERE price > 100.00 ORDER BY title; The example below demonstrates a query of multiple tables, grouping, and aggregation, by returning a list of books and the number of authors associated with each book. SELECT Book.title AS Title, count(*) AS Authors FROM Book JOIN Book_author ON Book.isbn = Book_author.isbn GROUP BY Book.title; Example output might resemble the following: Title Authors \\---------------------- ------- SQL Examples and Guide 4 The Joy of SQL 1 An Introduction to SQL 2 Pitfalls of SQL 1 Under the precondition that isbn is the only common column name of the two tables and that a column named title only exists in the Book table, one could re-write the query above in the following form: SELECT title, count(*) AS Authors FROM Book NATURAL JOIN Book_author GROUP BY title; However, many vendors either do not support this approach, or require certain column-naming conventions for natural joins to work effectively. SQL includes operators and functions for calculating values on stored values. SQL allows the use of expressions in the select list to project data, as in the following example, which returns a list of books that cost more than 100.00 with an additional sales_tax column containing a sales tax figure calculated at 6% of the price. SELECT isbn, title, price, price * 0.06 AS sales_tax FROM Book WHERE price > 100.00 ORDER BY title; === Subqueries === Queries can be nested so that the results of one query can be used in another query via a relational operator or aggregation function. A nested query is also known as a subquery. While joins and other table operations provide computationally superior (i.e. faster) alternatives in many cases, the use of subqueries introduces a hierarchy in execution that can be useful or necessary. In the following example, the aggregation function `AVG` receives as input the result of a subquery: SELECT isbn, title, price FROM Book WHERE price < (SELECT AVG(price) FROM Book) ORDER BY title; A subquery can use values from the outer query, in which case it is known as a correlated subquery. Since 1999 the SQL standard allows named subqueries called common table expressions (named and designed after the IBM DB2 version 2 implementation; Oracle calls these subquery factoring). CTEs can also be recursive by referring to themselves; the resulting mechanism allows tree or graph traversals (when represented as relations), and more generally fixpoint computations. === Derived table === A derived table is the use of referencing an SQL subquery in a FROM clause. Essentially, the derived table is a subquery that can be selected from or joined to. Derived table functionality allows the user to reference the subquery as a table. The derived table also is referred to as an inline view or a select in from list. In the following example, the SQL statement involves a join from the initial Books table to the derived table \"Sales\". This derived table captures associated book sales information using the ISBN to join to the Books table. As a result, the derived table provides the result set with additional columns (the number of items sold and the company that sold the books): SELECT b.isbn, b.title, b.price, sales.items_sold, sales.company_nm FROM Book b JOIN (SELECT SUM(Items_Sold) Items_Sold, Company_Nm, ISBN FROM Book_Sales GROUP BY Company_Nm, ISBN) sales ON sales.isbn = b.isbn == Examples == {| class=\"wikitable\" style=\"float: right; clear:right; margin: 1em\" border=\"1\" !Table \"T\" !Query !Result |- |align=\"center\"| {| cellpadding=\"2\" rules=\"all\" style=\"border: 1px solid gray; text-align: center;\" ! C1 !! C2 |- | 1 || a |- | 2 || b |} || |align=\"center\"| {| cellpadding=\"2\" rules=\"all\" style=\"border: 1px solid gray; text-align: center;\" ! C1 !! C2 |- | 1 || a |- | 2 || b |} |- |align=\"center\"| {| cellpadding=\"2\" rules=\"all\" style=\"border: 1px solid gray; text-align: center;\" ! C1 !! C2 |- | 1 || a |- | 2 || b |} || |align=\"center\"| {| cellpadding=\"2\" rules=\"all\" style=\"border: 1px solid gray; text-align: center;\" ! C1 |- | 1 |- | 2 |} |- |align=\"center\"| {| cellpadding=\"2\" rules=\"all\" style=\"border: 1px solid gray; text-align: center;\" ! C1 !! C2 |- | 1 || a |- | 2 || b |} || |align=\"center\"| {| cellpadding=\"2\" rules=\"all\" style=\"border: 1px solid gray; text-align: center;\" ! C1 !! C2 |- | 1 || a |} |- |align=\"center\"| {| cellpadding=\"2\" rules=\"all\" style=\"border: 1px solid gray; text-align: center;\" ! C1 !! C2 |- | 1 || a |- | 2 || b |} || |align=\"center\"| {| cellpadding=\"2\" rules=\"all\" style=\"border: 1px solid gray; text-align: center;\" ! C1 !! C2 |- | 2 || b |- | 1 || a |} |- |align=\"center\"|does not exist || |align=\"center\"| {| cellpadding=\"2\" rules=\"all\" style=\"border: 1px solid gray; text-align: center;\" ! `1+1` !! `3*2` |- | 2 || 6 |} |} Given a table T, the query will result in all the elements of all the rows of the table being shown. With the same table, the query will result in the elements from the column C1 of all the rows of the table being shown. This is similar to a projection in relational algebra, except that in the general case, the result may contain duplicate rows. This is also known as a Vertical Partition in some database terms, restricting query output to view only specified fields or columns. With the same table, the query will result in all the elements of all the rows where the value of column C1 is '1' being shown in relational algebra terms, a selection will be performed, because of the WHERE clause. This is also known as a Horizontal Partition, restricting rows output by a query according to specified conditions. With more than one table, the result set will be every combination of rows. So if two tables are T1 and T2, will result in every combination of T1 rows with every T2 rows. E.g., if T1 has 3 rows and T2 has 5 rows, then 15 rows will result. Although not in standard, most DBMS allows using a select clause without a table by pretending that an imaginary table with one row is used. This is mainly used to perform calculations where a table is not needed. The SELECT clause specifies a list of properties (columns) by name, or the wildcard character (“*”) to mean “all properties”. == Limiting result rows == Often it is convenient to indicate a maximum number of rows that are returned. This can be used for testing or to prevent consuming excessive resources if the query returns more information than expected. The approach to do this often varies per vendor. In ISO SQL:2003, result sets may be limited by using * cursors, or * by adding a SQL window function to the SELECT-statement ISO SQL:2008 introduced the `FETCH FIRST` clause. According to PostgreSQL v.9 documentation, an SQL window function \"performs a calculation across a set of table rows that are somehow related to the current row\", in a way similar to aggregate functions.PostgreSQL 9.1.24 Documentation - Chapter 3. Advanced Features The name recalls signal processing window functions. A window function call always contains an OVER clause. === ROW_NUMBER() window function === `ROW_NUMBER() OVER` may be used for a simple table on the returned rows, e.g. to return no more than ten rows: SELECT * FROM ( SELECT ROW_NUMBER() OVER (ORDER BY sort_key ASC) AS row_number, columns FROM tablename ) AS foo WHERE row_number <= 10 ROW_NUMBER can be non-deterministic: if sort_key is not unique, each time you run the query it is possible to get different row numbers assigned to any rows where sort_key is the same. When sort_key is unique, each row will always get a unique row number. === RANK() window function === The `RANK() OVER` window function acts like ROW_NUMBER, but may return more or less than n rows in case of tie conditions, e.g. to return the top-10 youngest persons: SELECT * FROM ( SELECT RANK() OVER (ORDER BY age ASC) AS ranking, person_id, person_name, age FROM person ) AS foo WHERE ranking <= 10 The above code could return more than ten rows, e.g. if there are two people of the same age, it could return eleven rows. === FETCH FIRST clause === Since ISO SQL:2008 results limits can be specified as in the following example using the `FETCH FIRST` clause. SELECT * FROM T FETCH FIRST 10 ROWS ONLY This clause currently is supported by CA DATACOM/DB 11, IBM DB2, SAP SQL Anywhere, PostgreSQL, EffiProz, H2, HSQLDB version 2.0, Oracle 12c and Mimer SQL. Microsoft SQL Server 2008 and higher supports `FETCH FIRST`, but it is considered part of the `ORDER BY` clause. The `ORDER BY`, `OFFSET`, and `FETCH FIRST` clauses are all required for this usage. SELECT * FROM T ORDER BY acolumn DESC OFFSET 0 ROWS FETCH FIRST 10 ROWS ONLY === Non-standard syntax === Some DBMSs offer non-standard syntax either instead of or in addition to SQL standard syntax. Below, variants of the simple limit query for different DBMSes are listed: {|class=\"wikitable\" |- | SET ROWCOUNT 10 SELECT * FROM T | MS SQL Server (This also works on Microsoft SQL Server 6.5 while the Select top 10 * from T does not) |- | SELECT * FROM T LIMIT 10 OFFSET 20 | Netezza, MySQL, MariaDB, SAP SQL Anywhere, PostgreSQL (also supports the standard, since version 8.4), SQLite, HSQLDB, H2, Vertica, Polyhedra, Couchbase Server, Snowflake Computing, OpenLink Virtuoso |- | SELECT * from T WHERE ROWNUM <= 10 | Oracle |- | `SELECT FIRST 10 * from T ` | Ingres |- | `SELECT FIRST 10 * FROM T order by a ` | Informix |- | `SELECT SKIP 20 FIRST 10 * FROM T order by c, d ` | Informix (row numbers are filtered after order by is evaluated. SKIP clause was introduced in a v10.00.xC4 fixpack) |- | `SELECT TOP 10 * FROM T` | MS SQL Server, SAP ASE, MS Access, SAP IQ, Teradata |- | SELECT * FROM T SAMPLE 10 | Teradata |- | `SELECT TOP 20, 10 * FROM T` | OpenLink Virtuoso (skips 20, delivers next 10) |- | `SELECT TOP 10 START AT 20 * FROM T` | SAP SQL Anywhere (also supports the standard, since version 9.0.1) |- | `SELECT FIRST 10 SKIP 20 * FROM T` | Firebird |- | SELECT * FROM T ROWS 20 TO 30 | Firebird (since version 2.1) |- | SELECT * FROM T WHERE ID_T > 10 FETCH FIRST 10 ROWS ONLY | IBM Db2 |- | SELECT * FROM T WHERE ID_T > 20 FETCH FIRST 10 ROWS ONLY | IBM Db2 (new rows are filtered after comparing with key column of table T) |} === Rows Pagination === Rows PaginationIng. Óscar Bonilla, MBA is an approach used to limit and display only a part of the total data of a query in the database. Instead of showing hundreds or thousands of rows at the same time, the server is requested only one page (a limited set of rows, per example only 10 rows), and the user starts navigating by requesting the next page, and then the next one, and so on. It is very useful, specially in web systems, where there is no dedicated connection between the client and the server, so the client does not have to wait to read and display all the rows of the server. ==== Data in Pagination approach ==== * `{rows}` = Number of rows in a page * `{page_number}` = Number of the current page * `{begin_base_0}` = Number of the row - 1 where the page starts = (page_number-1) * rows ==== Simplest method (but very inefficient) ==== # Select all rows from the database # Read all rows but send to display only when the row_number of the rows read is between `{begin_base_0 + 1}` and `{begin_base_0 + rows}` Select * from {table} order by {unique_key} ==== Other simple method (a little more efficient than read all rows) ==== # Select all the rows from the beginning of the table to the last row to display (`{begin_base_0 + rows}`) # Read the `{begin_base_0 + rows}` rows but send to display only when the row_number of the rows read is greater than `{begin_base_0}` {|class=\"wikitable\" |- ! SQL ! Dialect |- | select * from {table} order by {unique_key} FETCH FIRST {begin_base_0 + rows} ROWS ONLY | SQL ANSI 2008 PostgreSQL SQL Server 2012 Derby Oracle 12c DB2 12 Mimer SQL |- | Select * from {table} order by {unique_key} LIMIT {begin_base_0 + rows} | MySQL SQLite |- | Select TOP {begin_base_0 + rows} * from {table} order by {unique_key} | SQL Server 2005 |- | SET ROWCOUNT {begin_base_0 + rows} Select * from {table} order by {unique_key} SET ROWCOUNT 0 | Sybase, SQL Server 2000 |- | Select * FROM ( SELECT * FROM {table} ORDER BY {unique_key} ) a where rownum <= {begin_base_0 + rows} | Oracle 11 |} ==== Method with positioning ==== # Select only `{rows}` rows starting from the next row to display (`{begin_base_0 + 1}`) # Read and send to display all the rows read from the database {|class=\"wikitable\" |- ! SQL ! Dialect |- | Select * from {table} order by {unique_key} OFFSET {begin_base_0} ROWS FETCH NEXT {rows} ROWS ONLY | SQL ANSI 2008 PostgreSQL SQL Server 2012 Derby Oracle 12c DB2 12 Mimer SQL |- | Select * from {table} order by {unique_key} LIMIT {rows} OFFSET {begin_base_0} | MySQL MariaDB PostgreSQL SQLite |- | Select * from {table} order by {unique_key} LIMIT {begin_base_0}, {rows} | MySQL MariaDB SQLite |- | Select TOP {begin_base_0 + rows} *, _offset=identity(10) into #temp from {table} ORDER BY {unique_key} select * from #temp where _offset > {begin_base_0} DROP TABLE #temp | Sybase 12.5.3: |- | SET ROWCOUNT {begin_base_0 + rows} select *, _offset=identity(10) into #temp from {table} ORDER BY {unique_key} select * from #temp where _offset > {begin_base_0} DROP TABLE #temp SET ROWCOUNT 0 | Sybase 12.5.2: |- | select TOP {rows} * from ( select *, ROW_NUMBER() over (order by {unique_key}) as _offset from {table} ) xx where _offset > {begin_base_0} | SQL Server 2005 |- | SET ROWCOUNT {begin_base_0 + rows} select *, _offset=identity(int,1,1) into #temp from {table} ORDER BY {unique-key} select * from #temp where _offset > {begin_base_0} DROP TABLE #temp SET ROWCOUNT 0 | SQL Server 2000 |- | SELECT * FROM ( SELECT rownum-1 as _offset, a.* FROM( SELECT * FROM {table} ORDER BY {unique_key} ) a WHERE rownum <= {begin_base_0 + cant_regs} ) WHERE _offset >= {begin_base_0} | Oracle 11 |} ==== Method with filter (it is more sophisticated but necessary for very big dataset) ==== # Select only then `{rows}` rows with filter: ## First Page: select only the first `{rows}` rows, depending on the type of database ## Next Page: select only the first `{rows}` rows, depending on the type of database, where the `{unique_key}` is greater than `{last_val}` (the value of the `{unique_key}` of the last row in the current page) ## Previous Page: sort the data in the reverse order, select only the first `{rows}` rows, where the `{unique_key}` is less than `{first_val}` (the value of the `{unique_key}` of the first row in the current page), and sort the result in the correct order # Read and send to display all the rows read from the database {|class=\"wikitable\" |- ! First Page ! Next Page ! Previous Page ! Dialect |- | select * from {table} order by {unique_key} FETCH FIRST {rows} ROWS ONLY | select * from {table} where {unique_key} > {last_val} order by {unique_key} FETCH FIRST {rows} ROWS ONLY | select * from ( select * from {table} where {unique_key} < {first_val} order by {unique_key} DESC FETCH FIRST {rows} ROWS ONLY ) a order by {unique_key} | SQL ANSI 2008 PostgreSQL SQL Server 2012 Derby Oracle 12c DB2 12 Mimer SQL |- | select * from {table} order by {unique_key} LIMIT {rows} | select * from {table} where {unique_key} > {last_val} order by {unique_key} LIMIT {rows} | select * from ( select * from {table} where {unique_key} < {first_val} order by {unique_key} DESC LIMIT {rows} ) a order by {unique_key} | MySQL SQLite |- | select TOP {rows} * from {table} order by {unique_key} | select TOP {rows} * from {table} where {unique_key} > {last_val} order by {unique_key} | select * from ( select TOP {rows} * from {table} where {unique_key} < {first_val} order by {unique_key} DESC ) a order by {unique_key} | SQL Server 2005 |- | SET ROWCOUNT {rows} select * from {table} order by {unique_key} SET ROWCOUNT 0 | SET ROWCOUNT {rows} select * from {table} where {unique_key} > {last_val} order by {unique_key} SET ROWCOUNT 0 | SET ROWCOUNT {rows} select * from ( select * from {table} where {unique_key} < {first_val} order by {unique_key} DESC ) a order by {unique_key} SET ROWCOUNT 0 | Sybase, SQL Server 2000 |- | select * from ( select * from {table} order by {unique_key} ) a where rownum <= {rows} | select * from ( select * from {table} where {unique_key} > {last_val} order by {unique_key} ) a where rownum <= {rows} | select * from ( select * from ( select * from {table} where {unique_key} < {first_val} order by {unique_key} DESC ) a1 where rownum <= {rows} ) a2 order by {unique_key} | Oracle 11 |} == Hierarchical query == Some databases provide specialised syntax for hierarchical data. A window function in SQL:2003 is an aggregate function applied to a partition of the result set. For example, calculates the sum of the populations of all rows having the same city value as the current row. Partitions are specified using the OVER clause which modifies the aggregate. Syntax: The OVER clause can partition and order the result set. Ordering is used for order-relative functions such as row_number. == Query evaluation ANSI == The processing of a SELECT statement according to ANSI SQL would be the following:Inside Microsoft SQL Server 2005: T-SQL Querying by Itzik Ben-Gan, Lubor Kollar, and Dejan Sarka == Window function support by RDBMS vendors == The implementation of window function features by vendors of relational databases and SQL engines differs wildly. Most databases support at least some flavour of window functions. However, when we take a closer look it becomes clear that most vendors only implement a subset of the standard. Let's take the powerful RANGE clause as an example. Only Oracle, DB2, Spark/Hive, and Google Big Query fully implement this feature. More recently, vendors have added new extensions to the standard, e.g. array aggregation functions. These are particularly useful in the context of running SQL against a distributed file system (Hadoop, Spark, Google BigQuery) where we have weaker data co-locality guarantees than on a distributed relational database (MPP). Rather than evenly distributing the data across all nodes, SQL engines running queries against a distributed filesystem can achieve data co-locality guarantees by nesting data and thus avoiding potentially expensive joins involving heavy shuffling across the network. User-defined aggregate functions that can be used in window functions are another extremely powerful feature. == Generating data in T-SQL == Method to generate data based on the union all select 1 a, 1 b union all select 1, 2 union all select 1, 3 union all select 2, 1 union all select 5, 1 SQL Server 2008 supports the \"row constructor\" specified in the SQL3 (\"SQL:1999\") standard select * from (values (1, 1), (1, 2), (1, 3), (2, 1), (5, 1)) as x(a, b) == References == == Sources == * Horizontal & Vertical Partitioning, Microsoft SQL Server 2000 Books Online. == External links == * Windowed Tables and Window function in SQL, Stefan Deßloch * Oracle SELECT syntax * Firebird SELECT syntax * MySQL SELECT syntax * PostgreSQL SELECT syntax * SQLite SELECT syntax Category:SQL keywords Category:Articles with example SQL code",
 "title": "Select (SQL)"
}