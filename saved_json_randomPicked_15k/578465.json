{
 "id": "578465",
 "text": "In computer programming, specifically object-oriented programming, a class invariant (or type invariant) is an invariant used for constraining objects of a class. Methods of the class should preserve the invariant. The class invariant constrains the state stored in the object. Class invariants are established during construction and constantly maintained between calls to public methods. Code within functions may break invariants as long as the invariants are restored before a public function ends. With concurrency, maintaining the invariant in methods typically requires a critical section to be established by locking the state using a mutex. An object invariant, or representation invariant, is a computer programming construct consisting of a set of invariant properties that remain uncompromised regardless of the state of the object. This ensures that the object will always meet predefined conditions, and that methods may, therefore, always reference the object without the risk of making inaccurate presumptions. Defining class invariants can help programmers and testers to catch more bugs during software testing. ==Class invariants and inheritance== The useful effect of class invariants in object-oriented software is enhanced in the presence of inheritance. Class invariants are inherited, that is, \"the invariants of all the parents of a class apply to the class itself.\"Meyer, Bertrand. Object-Oriented Software Construction, second edition, Prentice Hall, 1997, p. 570. Inheritance can allow descendant classes to alter implementation data of parent classes, so it would be possible for a descendant class to change the state of instances in a way that made them invalid from the viewpoint of the parent class. The concern for this type of misbehaving descendant is one reason object-oriented software designers give for favoring composition over inheritance (i.e., inheritance breaks encapsulation).E. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, Reading, Massachusetts, 1995., p. 20. However, because class invariants are inherited, the class invariant for any particular class consists of any invariant assertions coded immediately on that class in conjunction with all the invariant clauses inherited from the class's parents. This means that even though descendant classes may have access to the implementation data of their parents, the class invariant can prevent them from manipulating those data in any way that produces an invalid instance at runtime. ==Programming language support== ===Assertions=== Common programming languages like Python,Official Python Docs, assert statement PHP, JavaScript, C++ and Java support assertions by default, which can be used to define class invariants. A common pattern to implement invariants in classes is for the constructor of the class to throw an exception if the invariant is not satisfied. Since methods preserve the invariants, they can assume the validity of the invariant and need not explicitly check for it. ===Native support=== The class invariant is an essential component of design by contract. So, programming languages that provide full native support for design by contract, such as Rust, Eiffel, Ada, and D, will also provide full support for class invariants. ===Non-native support=== For C++, the Loki Library provides a framework for checking class invariants, static data invariants, and exception safety. For Java, there is a more powerful tool called Java Modeling Language that provides a more robust way of defining class invariants. ==Examples== ===Native support=== ====D==== D programming language has native support of class invariants, as well as other contract programming techniques. Here is an example from the official documentation. class Date { int day; int hour; invariant() { assert(day >= 1 && day <= 31); assert(hour >= 0 && hour <= 23); } } ====Eiffel==== In Eiffel, the class invariant appears at the end of the class following the keyword `invariant`. class DATE create make feature {NONE} -- Initialization make (a_day: INTEGER; a_hour: INTEGER) \\-- Initialize `Current' with `a_day' and `a_hour'. require valid_day: a_day >= 1 and a_day <= 31 valid_hour: a_hour >= 0 and a_hour <= 23 do day := a_day hour := a_hour ensure day_set: day = a_day hour_set: hour = a_hour end feature -- Access day: INTEGER \\-- Day of month for `Current' hour: INTEGER \\-- Hour of day for `Current' feature -- Element change set_day (a_day: INTEGER) \\-- Set `day' to `a_day' require valid_argument: a_day >= 1 and a_day <= 31 do day := a_day ensure day_set: day = a_day end set_hour (a_hour: INTEGER) \\-- Set `hour' to `a_hour' require valid_argument: a_hour >= 0 and a_hour <= 23 do hour := a_hour ensure hour_set: hour = a_hour end invariant valid_day: day >= 1 and day <= 31 valid_hour: hour >= 0 and hour <= 23 end ===Non-native support=== ====C++==== The Loki (C++) library provides a framework written by Richard Sposato for checking class invariants, static data invariants, and exception safety level. This is an example of how class can use Loki::Checker to verify invariants remain true after an object changes. The example uses a geopoint object to store a location on Earth as a coordinate of latitude and longitude. The geopoint invariants are: * latitude may not be more than 90째 north. * latitude may not be less than -90째 south. * longitude may not be more than 180째 east. * longitude may not be less than -180째 west. #include // Needed to check class invariants. #include class GeoPoint { public: GeoPoint(Degrees latitude, Degrees longitude); /// Move function will move location of GeoPoint. void Move(Degrees latitude_change, Degrees longitude_change) { // The checker object calls IsValid at function entry and exit to prove this // GeoPoint object is valid. The checker also guarantees GeoPoint::Move // function will never throw. CheckFor::CheckForNoThrow checker(this, &IsValid;); latitude_ += latitude_change; if (latitude_ >= 90.0) latitude_ = 90.0; if (latitude_ <= -90.0) latitude_ = -90.0; longitude_ += longitude_change; while (longitude_ >= 180.0) longitude_ -= 360.0; while (longitude_ <= -180.0) longitude_ += 360.0; } private: /** @note CheckFor performs validity checking in many functions to determine if the code violated any invariants, if any content changed, or if the function threw an exception. */ using CheckFor = ::Loki::CheckFor; /// This function checks all object invariants. bool IsValid() const { assert(this != nullptr); assert(latitude_ >= -90.0); assert(latitude_ <= 90.0); assert(longitude_ >= -180.0); assert(longitude_ <= 180.0); return true; } Degrees latitude_; ///< Degrees from equator. Positive is north, negative is ///< south. Degrees longitude_; ///< Degrees from Prime Meridian. Positive is east, ///< negative is west. } ====Java==== This is an example of a class invariant in the Java programming language with Java Modeling Language. The invariant must hold to be true after the constructor is finished and at the entry and exit of all public member functions. Public member functions should define precondition and postcondition to help ensure the class invariant. public class Date { int /*@spec_public@*/ day; int /*@spec_public@*/ hour; /*@invariant day >= 1 && day <= 31; @*/ //class invariant /*@invariant hour >= 0 && hour <= 23; @*/ //class invariant /*@ @requires d >= 1 && d <= 31; @requires h >= 0 && h <= 23; @*/ public Date(int d, int h) { // constructor day = d; hour = h; } /*@ @requires d >= 1 && d <= 31; @ensures day == d; @*/ public void setDay(int d) { day = d; } /*@ @requires h >= 0 && h <= 23; @ensures hour == h; @*/ public void setHour(int h) { hour = h; } } ==References== Category:Class (computer programming)",
 "title": "Class invariant"
}