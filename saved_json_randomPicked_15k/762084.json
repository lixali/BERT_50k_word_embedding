{
 "id": "762084",
 "text": "Property Specification Language (PSL) is a temporal logic extending linear temporal logic with a range of operators for both ease of expression and enhancement of expressive power. PSL makes an extensive use of regular expressions and syntactic sugaring. It is widely used in the hardware design and verification industry, where formal verification tools (such as model checking) and/or logic simulation tools are used to prove or refute that a given PSL formula holds on a given design. PSL was initially developed by Accellera for specifying properties or assertions about hardware designs. Since September 2004 the standardization on the language has been done in IEEE 1850 working group. In September 2005, the IEEE 1850 Standard for Property Specification Language (PSL) was announced. == Syntax and semantics == PSL can express that if some scenario happens now, then another scenario should happen some time later. For instance, the property \"a should always eventually be ed\" can be expressed by the PSL formula: always (request -> eventually! grant) The property \"every which is immediately followed by an signal, should be followed by a complete , where a complete data transfer is a sequence starting with signal , ending with signal in which holds at the meantime\" can be expressed by the PSL formula: (true[*]; req; ack) |=> (start; busy[*]; end) A trace satisfying this formula is given in the figure on the right. thumb|a simple trace satisfying (true[*]; req; ack) |=> (start; busy[*]; end) PSL's temporal operators can be roughly classified into LTL-style operators and regular-expression-style operators. Many PSL operators come in two versions, a strong version, indicated by an exclamation mark suffix ( ), and a weak version. The strong version makes eventuality requirements (i.e. require that something will hold in the future), while the weak version does not. An underscore suffix ( ) is used to differentiate inclusive vs. non-inclusive requirements. An and suffixes are used to denote universal (all) vs. existential (exists) requirements. Exact time windows are denoted by and flexible by . === SERE-style operators=== The most commonly used PSL operator is the \"suffix-implication\" operator (a.k.a. the \"triggers\" operator), which is denoted by . Its left operand is a PSL regular expression and its right operand is any PSL formula (be it in LTL style or regular expression style). The semantics of is that on every time point i such that the sequence of time points up to i constitute a match to the regular expression r, the path from i+1 should satisfy the property p. This is exemplified in the figures on the right. thumb|path satisfying r triggers p in two non-overlapping ways thumb|path satisfying r triggers p in two overlapping ways thumb|path satisfying r triggers p' in three ways The regular expressions of PSL have the common operators for concatenation (), Kleene-closure (), and union (), as well as operator for fusion (), intersection () and a weaker version (), and many variations for consecutive counting and in-consecutive counting e.g. and . The trigger operator comes in several variations, shown in the table below. Here and are PSL-regular expressions, and is a PSL formula. {| class=\"wikitable\" | s |=> t! | if there is a match of s, then there is a match of t on the suffix of the trace, *t starts the cycle after s ends, *the match of t must reach to its end |- | s |-> t! | if there is a match of s, then there is a match of t on the suffix of the trace, *t starts the same cycle that s ends, *the match of t must reach to its end |- | s |=> t | if there is a match of s, then there is a match of t on the suffix of the trace, *t starts the cycle after s ends, *the match of t may \"get stuck\" in the middle |- | s |-> t | if there is a match of s, then there is a match of t on the suffix of the trace, *t starts the same cycle that s ends, *the match of t may \"get stuck\" in the middle |- |} Operators for concatenation, fusion, union, intersection and their variations are shown in the table below. Here and are PSL regular expressions. {| class=\"wikitable\" | ` s ; t ` | match of s followed by a match of t, t starts the cycle after s ends |- | `s : t ` | match of s followed by a match of t, t starts the same cycle that s ends |- | s | t | match of s or match of t |- | `s && t ` | match of s and match of t, duration of both is of same length |- | `s & t ` | match of s and match of t, duration matches maybe different |- | ` s within t ` | match of s within a match of t, abbreviation of ([*]; s; [*]) && (t) |- |} Operators for consecutive repetitions are shown in the table below. Here is a PSL regular expression. {| class=\"wikitable\" | ` s[*i] ` | i consecutive repetitions of s |- | ` s[*i..j] ` | between i to j consecutive repetitions of s |- | ` s[*i..] ` | at least i to consecutive repetitions of s |- | ` s[*] ` | zero or more consecutive repetitions of s |- | ` s[+] ` | one or more consecutive repetitions of s |- |} Operators for non-consecutive repetitions are shown in the table below. Here is any PSL Boolean expression. {| class=\"wikitable\" | ` b[=i] ` | i not necessarily consecutive repetitions of b, *equivalent to (!b[*];b)[*i]; !b[*] |- | b[=i..j] | at least i and no more than j not necessarily consecutive repetitions of b, *equivalent to (!b[*];b)[*i..j]; !b[*] |- | ` b[=i..] ` | at least i not necessarily consecutive repetitions of b, *equivalent to (!b[*];b)[*i..]; !b[*] |- | b[->m] | m not necessarily consecutive repetitions of b ending with b, *equivalent to (!b[*];b)[*m] |- | ` b[->m:n] ` | at least m and no more than n not necessarily consecutive repetitions of b ending with b, *equivalent to (!b[*];b)[*m..n] |- | ` b[->m..] ` | at least m not necessarily consecutive repetitions of b ending with b, *equivalent to (!b[*];b)[*m..]; !b[*] |- | ` b[->] ` | shortcut for b[->1], *equivalent to (!b[*];b) |- |} === LTL-style operators=== Below is a sample of some LTL-style operators of PSL. Here and are any PSL formulas. {| class=\"wikitable\" | | property p holds on every time point |- | | property p does not hold on any time point |- | | there exists a future time point where p holds |- | | there exists a next time point, and p holds on this point |- | | if there exists a next time point, then p holds on this point |- | | there exists an n-th time point, and p holds on this point |- | | if there exists an n-th time point, then p holds on this point |- | | there exists a time point, within m-th to n-th from the current where p holds. |- | | if there exists at least n-th time points, then p holds on one of the m-th to n-th points. |- | | there exists at least n more time points and p holds in all the time points between the m-th to the n-th, inclusive. |- | | p holds on all the next m-th through n-th time points, however many exist |- | | there exists a time point where q holds, and p hold up until that time point |- | | p holds up until a time point where q hold, if such exists |- | | there exists a time point where q holds, and p holds up until that time point and in that time point |- | | p holds up until a time point where q holds, and in that time point, if such exists |- | | p holds strictly before the time point where q holds, and p eventually holds |- | | p holds strictly before the time point where q holds, if p never holds, then neither does q |- | | p holds before or at the same time point where q holds, and p eventually holds |- | | p holds before or at the same time point where q holds, if p never holds, then neither does q |- |} === Sampling operator=== Sometimes it is desirable to change the definition of the next time-point, for instance in multiply-clocked designs, or when a higher level of abstraction is desired. The sampling operator (a.k.a. the clock operator), denoted , is used for this purpose. The formula where is a PSL formula and a PSL Boolean expressions holds on a given path if on that path projected on the cycles in which holds, as exemplified in the figures to the right. thumb|path and formula showing need for a sampling operator The first property states that \"every which is immediately followed by an signal, should be followed by a complete , where a complete data transfer is a sequence starting with signal , ending with signal in which should hold at least 8 times: (true[*]; req; ack) |=> (start; data[=8]; end) But sometimes it is desired to consider only the cases where the above signals occur on a cycle where is high. This is depicted in the second figure in which although the formula ((true[*]; req; ack) |=> (start; data[*3]; end)) @ clk uses and is consecutive repetition, the matching trace has 3 non-consecutive time points where holds, but when considering only the time points where holds, the time points where hold become consecutive. thumb|path and formula showing effect of the sampling operator @ The semantics of formulas with nested @ is a little subtle. The interested reader is referred to [2]. === Abort operators === PSL has several operators to deal with truncated paths (finite paths that may correspond to a prefix of the computation). Truncated paths occur in bounded-model checking, due to resets and in many other scenarios. The abort operators, specify how eventualities should be dealt with when a path has been truncated. They rely on the truncated semantics proposed in [1]. Here is any PSL formula and is any PSL Boolean expression. {| class=\"wikitable\" | ` p async_abort b ` | either p holds or p does not fail up until b holds; * b recognized asynchronously |- | ` p sync_abort b ` | either p holds or p does not fail up until b holds; * b recognized synchronously |- | ` p abort b ` | equivalent to p async_abort b |- |} ===Expressive power=== PSL subsumes the temporal logic LTL and extends its expressive power to that of the omega- regular languages. The augmentation in expressive power, compared to that of LTL, which has the expressive power of the star-free ω-regular expressions, can be attributed to the suffix implication, a.k.a. triggers operator, denoted \"|->\". The formula r |-> f where r is a regular expression and f is a temporal logic formula holds on a computation w if any prefix of w matching r has a continuation satisfying f. Other non-LTL operators of PSL are the @ operator, for specifying multiply-clocked designs, the abort operators, for dealing with hardware resets, and local variables for succinctness. ===Layers=== PSL is defined in 4 layers: the Boolean layer, the temporal layer, the modeling layer and the verification layer. *The Boolean layer is used for describing a current state of the design and is phrased using one of the above-mentioned HDLs. *The temporal layer consists of the temporal operators used to describe scenarios that span over time (possibly over an unbounded number of time units). *The modeling layer can be used to describe auxiliary state machines in a procedural manner. *The verification layer consists of directives to a verification tool (for instance to assert that a given property is correct or to assume that a certain set of properties is correct when verifying another set of properties). ===Language compatibility=== Property Specification Language can be used with multiple electronic system design languages (HDLs) such as: * VHDL (IEEE 1076) * Verilog (IEEE 1364) * SystemVerilog (IEEE 1800) * SystemC (IEEE 1666) by Open SystemC Initiative (OSCI). When PSL is used in conjunction with one of the above HDLs, its Boolean layer uses the operators of the respective HDL. ==References== * **IEC 62531:2007 * **IEC 62531:2012 * * ==External links== * IEEE 1850 working group * IEEE Announcement September 2005 * Accellera * Property Specification Language Tutorial * Designers guide to PSL ===Books on PSL=== * Using PSL/Sugar for Formal and Dynamic Verification 2nd Edition, Ben Cohen, Ajeetha Kumari, Srinivasan Venkataramanan * A Practical Introduction to PSL, Cindy Eisner, Dana Fisman Category:Hardware verification languages Category:Formal specification languages Category:IEEE DASC standards Category:IEC standards",
 "title": "Property Specification Language"
}