{
 "id": "189937",
 "text": "A universally unique identifier (UUID) is a 128-bit label used for information in computer systems. The term globally unique identifier (GUID) is also used. When generated according to the standard methods, UUIDs are, for practical purposes, unique. Their uniqueness does not depend on a central registration authority or coordination between the parties generating them, unlike most other numbering schemes. While the probability that a UUID will be duplicated is not zero, it is close enough to zero to be negligible.ITU-T Recommendation X.667: Generation and registration of Universally Unique Identifiers (UUIDs) and their use as ASN.1 Object Identifier components. Standard. October 2012. Thus, anyone can create a UUID and use it to identify something with near certainty that the identifier does not duplicate one that has already been, or will be, created to identify something else. Information labeled with UUIDs by independent parties can therefore be later combined into a single database or transmitted on the same channel, with a negligible probability of duplication. Adoption of UUIDs is widespread, with many computing platforms providing support for generating them and for parsing their textual representation. ==History== In the 1980s Apollo Computer originally used UUIDs in the Network Computing System (NCS) and later in the Open Software Foundation's (OSF) Distributed Computing Environment (DCE). The initial design of DCE UUIDs was based on the NCS UUIDs, whose design was in turn inspired by the (64-bit) unique identifiers defined and used pervasively in Domain/OS, an operating system designed by Apollo Computer. Later, the Microsoft Windows platforms adopted the DCE design as \"globally unique identifiers\" (GUIDs). RFC 4122 registered a URN namespace for UUIDs and recapitulated the earlier specifications, with the same technical content. When in July 2005 RFC 4122 was published as a proposed IETF standard, the ITU had also standardized UUIDs, based on the previous standards and early versions of RFC 4122. ==Standards== UUIDs are standardized by the Open Software Foundation (OSF) as part of the Distributed Computing Environment (DCE). UUIDs are documented as part of ISO/IEC 11578:1996 \"Information technology – Open Systems Interconnection – Remote Procedure Call (RPC)\" and more recently in ITU-T Rec. X.667 | ISO/IEC 9834-8:2005. The Internet Engineering Task Force (IETF) published the Standards-Track RFC 4122, technically equivalent to ITU-T Rec. X.667 | ISO/IEC 9834-8. ==Format== In its canonical textual representation, the 16 octets of a UUID are represented as 32 hexadecimal (base-16) digits, displayed in five groups separated by hyphens, in the form 8-4-4-4-12 for a total of 36 characters (32 hexadecimal characters and 4 hyphens). For example: : `123e4567-e89b-12d3-a456-426614174000` : `xxxxxxxx-xxxx-Mxxx-Nxxx- xxxxxxxxxxxx` The four-bit M and the 1 to 3 bit fields code the format of the UUID itself. The four bits of digit `M` are the UUID version, and the 1 to 3 most significant bits of digit `N` code the UUID variant. (See below.) In the example, M is `1`, and N is `a` (10xx2), meaning that this is a version-1, variant-1 UUID; that is, a time-based DCE/RFC 4122 UUID. The canonical 8-4-4-4-12 format string is based on the record layout for the 16 bytes of the UUID: {|class=\"wikitable\" |+ UUID record layout |- ! Name ! Length (bytes) ! Length (hex digits) ! Length (bits) ! Contents |- | time_low | 4 | 8 | 32 | integer giving the low 32 bits of the time |- | time_mid | 2 | 4 | 16 | integer giving the middle 16 bits of the time |- | time_hi_and_version | 2 | 4 | 16 | 4-bit \"version\" in the most significant bits, followed by the high 12 bits of the time |- | clock_seq_hi_and_res clock_seq_low | 2 | 4 | 16 | 1 to 3-bit \"variant\" in the most significant bits, followed by the 13 to 15-bit clock sequence |- | node | 6 | 12 | 48 | the 48-bit node id |} These fields correspond to those in version 1 and 2 UUIDs (that is, time-based UUIDs), but the same 8-4-4-4-12 representation is used for all UUIDs, even for UUIDs constructed differently. RFC 4122 Section 3 requires that the characters be generated in lower case, while being case-insensitive on input. Microsoft GUIDs are sometimes represented with surrounding braces: : `{123e4567-e89b-12d3-a456-426652340000}` This format should not be confused with \"Windows Registry format\", which refers to the format within the curly braces. RFC 4122 defines a Uniform Resource Name (URN) namespace for UUIDs. A UUID presented as a URN appears as follows: : `urn:uuid:123e4567-e89b-12d3-a456-426655440000` ==Encoding== The binary encoding of UUIDs varies between systems. Variant 1 UUIDs, nowadays the most common variant, are encoded in a big-endian format. For example, `00112233-4455-6677-8899-aabbccddeeff` is encoded as the bytes `00 11 22 33` `44 55` `66 77` `88 99` `aa bb cc dd ee ff`. Variant 2 UUIDs, historically used in Microsoft's COM/OLE libraries, use a mixed-endian format, whereby the first three components of the UUID are little-endian, and the last two are big-endian. For example, `00112233-4455-6677-c899-aabbccddeeff` is encoded as the bytes `33 22 11 00` `55 44` `77 66` `c8 99` `aa bb cc dd ee ff`. See the section on Variants for details on why the '88' byte becomes 'c8' in Variant 2. ==Variants== The \"variant\" field of UUIDs, or the N position indicate their format and encoding. RFC 4122 defines four variants of lengths 1 to 3 bits: * Variant 0 (indicated by the one-bit pattern 0xxx2, N = `0..7`) is for backwards compatibility with the now-obsolete Apollo Network Computing System 1.5 UUID format developed around 1988. The first 6 octets of the UUID are a 48-bit timestamp (the number of 4-microsecond units of time since 1 January 1980 UTC); the next 2 octets are reserved; the next octet is the \"address family\"; and the final 7 octets are a 56-bit host ID in the form specified by the address family. Though different in detail, the similarity with modern version-1 UUIDs is evident. The variant bits in the current UUID specification coincide with the high bits of the address family octet in NCS UUIDs. Though the address family could hold values in the range 0..255, only the values 0..13 were ever defined. Accordingly, the variant-0 bit pattern `0xxx` avoids conflicts with historical NCS UUIDs, should any still exist in databases. * Variant 1 (10xx2, N = `8..b`, 2 bits) are referred to as RFC 4122/DCE 1.1 UUIDs, or \"Leach–Salz\" UUIDs, after the authors of the original Internet Draft. * Variant 2 (110x2, = `c..d`, 3 bits) is characterized in the RFC as \"reserved, Microsoft Corporation backward compatibility\" and was used for early GUIDs on the Microsoft Windows platform. It differs from variant 1 only by the endianness in binary storage or transmission: variant-1 UUIDs use \"network\" (big-endian) byte order, while variant-2 GUIDs use \"native\" (little- endian) byte order for some subfields of the UUID. * Reserved is defined as the 3-bit variant bit pattern 111x2 (N = `e..f`). Variants 1 and 2 are used by the current UUID specification. In their textual representations, variants 1 and 2 are the same, except for the variant bits. In the binary representation, there is an endianness difference. When byte swapping is required to convert between the big-endian byte order of variant 1 and the little-endian byte order of variant 2, the fields above define the swapping. The first three fields are unsigned 32- and 16-bit integers and are subject to swapping, while the last two fields consist of uninterpreted bytes, not subject to swapping. This byte swapping applies even for versions 3, 4, and 5, where the canonical fields do not correspond to the content of the UUID. While some important GUIDs, such as the identifier for the Component Object Model IUnknown interface, are nominally variant-2 UUIDs, many identifiers generated and used in Microsoft Windows software and referred to as \"GUIDs\" are standard variant-1 RFC 4122/DCE 1.1 network-byte-order UUIDs, rather than little-endian variant-2 UUIDs. The current version of the Microsoft `guidgen` tool produces standard variant-1 UUIDs. Some Microsoft documentation states that \"GUID\" is a synonym for \"UUID\", as standardized in RFC 4122. RFC 4122 itself states that UUIDs \"are also known as GUIDs\". All this suggests that \"GUID\", while originally referring to a variant of UUID used by Microsoft, has become simply an alternative name for UUID, with both variant-1 and variant-2 GUIDs being extant. ==Versions== For both variants 1 and 2, five \"versions\" are defined in the standards, and each version may be more appropriate than the others in specific use cases. Version is indicated by the `M` in the string representation. Version-1 UUIDs are generated from a time and a node ID (usually the MAC address); version-2 UUIDs are generated from an identifier (usually a group or user ID), time, and a node ID; versions 3 and 5 produce deterministic UUIDs generated by hashing a namespace identifier and name; and version-4 UUIDs are generated using a random or pseudo-random number. ===Nil UUID=== The \"nil\" UUID, a special case, is the UUID `00000000-0000-0000-0000-000000000000`; that is, all bits set to zero. ===Version 1 (date-time and MAC address)=== Version 1 concatenates the 48-bit MAC address of the \"node\" (that is, the computer generating the UUID), with a 60-bit timestamp, being the number of 100-nanosecond intervals since midnight 15 October 1582 Coordinated Universal Time (UTC), the date on which the Gregorian calendar was first adopted. RFC 4122 states that the time value rolls over around 3400 AD, depending on the algorithm used, which implies that the 60-bit timestamp is a signed quantity. However some software, such as the libuuid library, treats the timestamp as unsigned, putting the rollover time in 5236 AD. The rollover time as defined by ITU-T Rec. X.667 is 3603 AD. A 13-bit or 14-bit \"uniquifying\" clock sequence extends the timestamp in order to handle cases where the processor clock does not advance fast enough, or where there are multiple processors and UUID generators per node. When UUIDs are generated faster than the system clock could advance, the lower bits of the timestamp fields can be generated by incrementing it every time a UUID is being generated, to simulate a high-resolution timestamp. With each version 1 UUID corresponding to a single point in space (the node) and time (intervals and clock sequence), the chance of two properly generated version-1 UUIDs being unintentionally the same is practically nil. Since the time and clock sequence total 74 bits, 274 (1.8, or 18 sextillion) version-1 UUIDs can be generated per node ID, at a maximal average rate of 163 billion per second per node ID. In contrast to other UUID versions, version-1 and -2 UUIDs based on MAC addresses from network cards rely for their uniqueness in part on an identifier issued by a central registration authority, namely the Organizationally Unique Identifier (OUI) part of the MAC address, which is issued by the IEEE to manufacturers of networking equipment. The uniqueness of version-1 and version-2 UUIDs based on network-card MAC addresses also depends on network-card manufacturers properly assigning unique MAC addresses to their cards, which like other manufacturing processes is subject to error. Additionally some operating system permit the end user to customise the MAC address, notably OpenWRT. Usage of the node's network card MAC address for the node ID means that a version-1 UUID can be tracked back to the computer that created it. Documents can sometimes be traced to the computers where they were created or edited through UUIDs embedded into them by word processing software. This privacy hole was used when locating the creator of the Melissa virus. RFC 4122 does allow the MAC address in a version-1 (or 2) UUID to be replaced by a random 48-bit node ID, either because the node does not have a MAC address, or because it is not desirable to expose it. In that case, the RFC requires that the least significant bit of the first octet of the node ID should be set to 1. This corresponds to the multicast bit in MAC addresses, and setting it serves to differentiate UUIDs where the node ID is randomly generated from UUIDs based on MAC addresses from network cards, which typically have unicast MAC addresses. ===Version 2 (date-time and MAC address, DCE security version)=== RFC 4122 reserves version 2 for \"DCE security\" UUIDs; but it does not provide any details. For this reason, many UUID implementations omit version 2. However, the specification of version-2 UUIDs is provided by the DCE 1.1 Authentication and Security Services specification. Version-2 UUIDs are similar to version 1, except that the least significant 8 bits of the clock sequence are replaced by a \"local domain\" number, and the least significant 32 bits of the timestamp are replaced by an integer identifier meaningful within the specified local domain. On POSIX systems, local-domain numbers 0 and 1 are for user ids (UIDs) and group ids (GIDs) respectively, and other local-domain numbers are site-defined. On non-POSIX systems, all local domain numbers are site-defined. The ability to include a 40-bit domain/identifier in the UUID comes with a tradeoff. On the one hand, 40 bits allow about 1 trillion domain/identifier values per node ID. On the other hand, with the clock value truncated to the 28 most significant bits, compared to 60 bits in version 1, the clock in a version 2 UUID will \"tick\" only once every 429.49 seconds, a little more than 7 minutes, as opposed to every 100 nanoseconds for version 1. And with a clock sequence of only 6 bits, compared to 14 bits in version 1, only 64 unique UUIDs per node/domain/identifier can be generated per 7-minute clock tick, compared to 16,384 clock sequence values for version 1. Thus, Version 2 may not be suitable for cases where UUIDs are required, per node/domain/identifier, at a rate exceeding about one every seven minutes. ===Versions 3 and 5 (namespace name-based)=== Version-3 and version-5 UUIDs are generated by hashing a namespace identifier and name. Version 3 uses MD5 as the hashing algorithm, and version 5 uses SHA-1. The namespace identifier is itself a UUID. The specification provides UUIDs to represent the namespaces for URLs, fully qualified domain names, object identifiers, and X.500 distinguished names; but any desired UUID may be used as a namespace designator. To determine the version-3 UUID corresponding to a given namespace and name, the UUID of the namespace is transformed to a string of bytes, concatenated with the input name, then hashed with MD5, yielding 128 bits. Then 6 or 7 bits are replaced by fixed values, the 4-bit version (e.g. 00112 for version 3), and the 2- or 3-bit UUID \"variant\" (e.g. 102 indicating a RFC 4122 UUIDs, or 1102 indicating a legacy Microsoft GUID). Since 6 or 7 bits are thus predetermined, only 121 or 122 bits contribute to the uniqueness of the UUID. Version-5 UUIDs are similar, but SHA-1 is used instead of MD5. Since SHA-1 generates 160-bit digests, the digest is truncated to 128 bits before the version and variant bits are replaced. Version-3 and version-5 UUIDs have the property that the same namespace and name will map to the same UUID. However, neither the namespace nor name can be determined from the UUID, even if one of them is specified, except by brute-force search. RFC 4122 recommends version 5 (SHA-1) over version 3 (MD5), and warns against use of UUIDs of either version as security credentials. ===Version 4 (random)=== A version 4 UUID is randomly generated. As in other UUIDs, 4 bits are used to indicate version 4, and 2 or 3 bits to indicate the variant (102 or 1102 for variants 1 and 2 respectively). Thus, for variant 1 (that is, most UUIDs) a random version-4 UUID will have 6 predetermined variant and version bits, leaving 122 bits for the randomly generated part, for a total of 2122, or 5.3 (5.3 undecillion) possible version-4 variant-1 UUIDs. There are half as many possible version-4 variant-2 UUIDs (legacy GUIDs) because there is one fewer random bit available, 3 bits being consumed for the variant. ==Collisions== Collision occurs when the same UUID is generated more than once and assigned to different referents. In the case of standard version-1 and version-2 UUIDs using unique MAC addresses from network cards, collisions are unlikely to occur, with an increased possibility only when an implementation varies from the standards, either inadvertently or intentionally. In contrast to version-1 and version-2 UUIDs generated using MAC addresses, with version-1 and -2 UUIDs which use randomly generated node ids, hash-based version-3 and version-5 UUIDs, and random version-4 UUIDs, collisions can occur even without implementation problems, albeit with a probability so small that it can normally be ignored. This probability can be computed precisely based on analysis of the birthday problem. For example, the number of random version-4 UUIDs which need to be generated in order to have a 50% probability of at least one collision is 2.71 quintillion, computed as follows: : n \\approx \\frac{1}{2} + \\sqrt{\\frac{1}{4} + 2 \\times \\ln(2) \\times 2^{122}} \\approx 2.71 \\times 10^{18}. This number is equivalent to generating 1 billion UUIDs per second for about 85 years. A file containing this many UUIDs, at 16 bytes per UUID, would be about 45 exabytes. The smallest number of version-4 UUIDs which must be generated for the probability of finding a collision to be p is approximated by the formula : \\sqrt{2 \\times 2^{122} \\times \\ln\\frac{1}{1 - p}}. Thus, the probability to find a duplicate within 103 trillion version-4 UUIDs is one in a billion. ==Uses== ===File systems=== Significant uses include ext2/ext3/ext4 filesystem userspace tools (e2fsprogs uses libuuid provided by util-linux), LVM, LUKS encrypted partitions, GNOME, KDE, and macOS,gen_uuid.c in Apple's Libc-391, corresponding to Mac OS X 10.4 most of which are derived from the original implementation by Theodore Ts'o. One of the uses of UUIDs in Solaris (using Open Software Foundation implementation) is identification of a running operating system instance for the purpose of pairing crash dump data with Fault Management Event in the case of kernel panic. The \"partition label\" and the \"partition UUID\" are both stored in the superblock. They are both rather part of the file system, then of the partition. For example, ext2–4, contain a UUID, while NTFS or FAT32 do not! The superblock is a part of the file system, thus fully contained within the partition, hence if you do a , both sda1 and sdb1 will have the same label and UUID. ===In COM=== There are several flavors of GUIDs used in Microsoft's Component Object Model (COM): * – interface identifier; (The ones that are registered on a system are stored in the Windows Registry at ) * – class identifier; (Stored at ) * – type library identifier; (Stored at ) * – category identifier; (its presence on a class identifies it as belonging to certain class categories, listed at ) ===As database keys=== UUIDs are commonly used as a unique key in database tables. The function in Microsoft SQL Server version 4 Transact-SQL returns standard random version-4 UUIDs, while the function returns 128-bit identifiers similar to UUIDs which are committed to ascend in sequence until the next system reboot. The Oracle Database function does not return a standard GUID, despite the name. Instead, it returns a 16-byte 128-bit RAW value based on a host identifier and a process or thread identifier, somewhat similar to a GUID. PostgreSQL contains a datatype and can generate most versions of UUIDs through the use of functions from modules. MySQL provides a function, which generates standard version-1 UUIDs. The random nature of standard UUIDs of versions 3, 4, and 5, and the ordering of the fields within standard versions 1 and 2 may create problems with database locality or performance when UUIDs are used as primary keys. For example, in 2002 Jimmy Nilsson reported a significant improvement in performance with Microsoft SQL Server when the version-4 UUIDs being used as keys were modified to include a non-random suffix based on system time. This so-called \"COMB\" (combined time-GUID) approach made the UUIDs non-standard and significantly more likely to be duplicated, as Nilsson acknowledged, but Nilsson only required uniqueness within the application. By reordering and encoding version 1 and 2 UUIDs so that the timestamp comes first, insertion performance loss can be averted. Some web frameworks, such as Laravel, have support for \"timestamp first\" UUIDs that may be efficiently stored in an indexed database column. This makes a COMB UUID using version 4 format, but where the first 48-bits make up a timestamp laid out like in UUIDv1. More specified formats based on the COMB UUID idea include: * \"ULID\", which ditches the 4 bits used to indicate version 4, and uses a base32 encoding by default. * UUID versions 6 through 8, a formal proposal of three COMB UUID formats. ==See also== * Birthday attack * Object identifier (OID) * Uniform Resource Identifier (URI) * Snowflake ID ==References== ==External links== Standards * Recommendation ITU-T X.667 (Free access) * ISO/IEC 9834-8:2014 (Paid) ITU-T UUID Generator * Universally Unique Identifiers (UUIDs) Technical Articles * Technical Note TN2166 - Secrets of the GPT - Apple Developer * UUID Documentation - Commons Id * Class UUID - Java Documentation * CLSID Key - Microsoft Docs * Universal Unique Identifier - The Open Group Library Miscellaneous * UUID Decoder tool * A Brief History of the UUID * Understanding How UUIDs Are Generated Implementation in various languages * Golang - google/uuid * PHP - ramsey/uuid * C++ - Boost UUID * Linux or C - libuuid * Python - uuid.py * Java - java.util.UUID * C# - System.Guid * Javascript - Crypto.randomUUID Category:Unique identifiers Category:Windows administration Category:1996 establishments",
 "title": "Universally unique identifier"
}